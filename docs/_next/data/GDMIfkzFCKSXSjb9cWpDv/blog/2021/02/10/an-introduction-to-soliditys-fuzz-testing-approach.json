{"pageProps":{"frontmatter":{"layout":"post","published":true,"title":"An Introduction to Solidity's Fuzz Testing Approach","date":"2021-02-10","author":"Bhargava Shastry","category":"Explainers"},"content":"\nSecurity vulnerabilities and bugs detract from software quality.\nTo discover them early, at best before they are released, we have adopted fuzz testing: feeding randomly generated programs to the Solidity compiler and observing the compilation runtime and code generated.\n\nSince Q1 2019, the Solidity compiler is fuzz tested via Google's [open-source software fuzz][1] (oss-fuzz) framework.\n\nIn this post, we briefly describe the work that has been done on this front, and work that is currently in progress.\n\n### Fuzzer Overview\n\nBroadly speaking, we have developed two classes of fuzzers:\n\n- Front-end fuzzers that test the compiler front-end (parser/analyser).\n- Back-end fuzzers that test the compiler back-end (optimiser).\n\n### Front-end Fuzzers\n\nWe have developed front-end fuzzers in order to test if programs are parsed and analysed correctly.\nFront-end fuzzing comprises mutating existing test cases (most often unit tests) in order to test how parsing and program analysis respond to corner case input.\n\nFuzzing is effective because the Solidity compiler makes heavy use of assertions both during the input program parsing/analysis phase as well as the code generation phase.\nInputs generated by front-end fuzzers may fail such assertions, signalling an error in the compiler.\n\n#### Example bug found by front-end fuzzer\n\nSolidity implements the [NatSpec format][3] for code documentation.\nThe front-end fuzzer generated the following program that led to an assertion failure in the compiler (see Notes for more information):\n\n```\ncontract C {\n    ///@return\n    modifier m22 {}\n}\n\ncontract D is C {\n    modifier m22 {}\n}\n```\n\nThe program was presumably mutated from the following perfectly valid test program.\n\n```\ncontract C {\n    modifier m22 { _; }\n}\ncontract D is C {\n}\n```\n\nThe mutations prepended the `///@return` line to the modifier declaration and copied the modifier declaration to the derived contract.\n\nA natural question is the following: How did the fuzzer \"know\" that this particular mutation will lead to an error?\nThe answer is that it does not know; the fuzzer simply mutates existing input to create new inputs and it just so happened that this mutation discovered a bug.\nA follow-up question could be: How are mutations created?\nBroadly speaking, mutations fall into one of the following categories:\n\n- Flipping bits at certain positions in the input stream.\n- Adding bits possibly supported by a hand-written dictionary.\n- Shuffling bits.\n- Removing bits.\n\nSince Solidity programs are strings, it may be useful to think of the mutation classes in terms of characters (e.g., `a-z`) than bits.\n\nA second follow-up question could be: Wait a minute! Random mutations are rarely useful? In which case, how can they find bugs?\nThe short answer is yes, they are rarely useful if the end-goal is to create a valid program.\nFor example it is a lot more likely to mutate `if (true) {}` into `iff (true) {}` (suffix `f` to the `if` keyword) than `if (false) {}`.\nThe likely mutation is simply going to lead to a parsing error which is rather uninteresting.\nBut please bear in mind that the goal here is to test the compiler front-end, and to this end, random mutations are rather useful.\nEspecially programs generated by a mix of randomness and human support (dictionary of Solidity keywords).\nThis is borne out by the test case generated by the fuzzer by, among other things, prepending the `///@return` NatSpec comment.\n\nIf you are curious as to how the fuzzer may have \"synthesised\" the NatSpec comment, one of the ways (caution: pure speculation) is the following:\n\n- In some fuzzer run `N`, adding dictionary token \"//\" (i.e., comment syntax in Solidity).\n- In run `N' > N`, adding dictionary token \"return\".\n- Finally, arriving at `///@return` through a sequence of additions/shuffling.\n\nThe Solidity fuzzing dictionary [may be found here][5].\nIf you spot omissions (especially those that may yield interesting mutants), please let us know.\nPRs welcome. :-)\n\nWe would like to thank external contributors Alex Groce and Charalambos Mitropoulos for independently fuzzing the Solidity compiler and reporting bugs.\n\n**Notes**:\n\nThis [issue][4] is a few months old and has been fixed in `0.7.6`.\nThe issue is that Solidity modifiers don't have return variables, and hence a `@return` NatSpec tag does not make sense.\nThe program above should have resulted in a parsing error (which is what the fix ensures) but instead resulted in a failed assertion.\n\n### Back-end Fuzzers\n\nIn order to test if code generation is sound, a valid program (input) needs to be fed to the compiler.\nIf the program contains syntactic (`iff` instead of `if`) or semantic (use undeclared identifier) errors, it won't be accepted by the compiler.\nSemantic fuzzers are designed to ensure program input does not contain such errors.\n\nTo implement semantic fuzzers, we rely on Google's [libprotobuf-mutator][2] library.\nBroadly speaking, writing a semantic fuzzer involves the following steps:\n\n- Write a (context-free) grammar for Solidity in the protobuf interface definition language.\n- Implement a converter interface that accepts a generation of the protobuf grammar and converts into target language.\n\nWe have implemented one such semantic fuzzer for testing the correctness of the Yul optimiser.\nThe fuzzer randomly generates Yul programs whose behavior is tracked pre and post optimisation in order to flag stateful divergence.\nThis helps us determine if a bug was introduced into the optimiser.\n\n#### Example bug found by back-end fuzzer\n\nThe redundant assignment eliminator is a Yul optimiser step that (surpise!) removes redundant assignments to a variable.\nThe back-end fuzzer generated the following example that demonstrated an error in this step:\n\n```\n{\n        for {let i:= 0} lt(i,2) {i := add(i,1)}\n        {\n                // x is declared and implicitly\n                // initialized to zero.\n                let x\n                // This assignment is not redundant\n                // since it is used by the mstore statement\n                // after the if statement\n                x := 1337\n                if lt(i,1) {\n                        // This assignment is redundant because of the `continue`\n                        x := 42\n                        continue\n                }\n                mstore(0, x)\n        }\n}\n```\n\nThe redundant assignment eliminator eliminated all assignments to `x` leading to `mstore(0, x)`, thereby optimising the program to one containing `mstore(0, 0)` instead of `mstore(0, 1337)`.\nThis [bug][8] has been [fixed in `0.6.1`][9].\n\nHow does the fuzzer generate such programs?\nThe answer, in a nutshell, is the following. In each fuzzing iteration:\n\n- Libprotobuf-mutator creates a generation of the protobuf grammar for Yul.\n- Libprotobuf parses this generation to ensure it is a valid protobuf message.\n- If valid, the protobuf message is accepted by the converter that we have written.\n- The converter converts this protobuf message into a yul program.\n\nIf you are interested in taking a look at the protobuf grammar for Yul and the converter, please take a look [here][6] and [there][7].\nContributions for improving the grammar/converter are welcome as always.\n\n### Work in Progress\n\nCurrently, we are working on a new Solidity program generator that is independent of libprotobuf and libprotobuf-mutator.\nThe main reason for this is that the protobuf IDL is hardly suited to capturing programming language semantics.\nMoreover, it is quite laborious to write context-free grammar for high-level programming languages.\n\nThe end goal of the new fuzzer generator is to be able to automatically generate a well-formed Solidity program.\nOnce this is implemented, we plan to compile/optimise and potentially execute the resulting bytecode on the EVM virtual machine.\nThis will help us discover otherwise difficult-to-find bugs introduced by the compiler that show up only when EVM state is examined.\n\nWatch this space for more updates on Solidity fuzzing!\n\n[1]: https://github.com/google/oss-fuzz\n[2]: https://github.com/google/libprotobuf-mutator\n[3]: https://docs.soliditylang.org/en/develop/natspec-format.html\n[4]: https://github.com/ethereum/solidity/issues/10433\n[5]: https://www.github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/config/solidity.dict\n[6]: https://www.github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/yulProto.proto\n[7]: https://www.github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/protoToYul.cpp\n[8]: https://github.com/ethereum/solidity/issues/8072\n[9]: https://github.com/ethereum/solidity/pull/8082\n","availableURLs":["/2023/05/10/solidity-0.8.20-release-announcement","/2023/03/10/solidity-developer-survey-2022-results","/2023/02/22/user-defined-operators","/2023/02/22/solidity-0.8.19-release-announcement","/2023/02/01/solidity-0.8.18-release-announcement","/2022/12/07/solidity-developer-survey-2022-announcement","/2022/12/05/solidity-core-team-updates","/2022/09/08/storage-write-removal-before-conditional-termination","/2022/09/08/solidity-0.8.17-release-announcement","/2022/08/08/solidity-0.8.16-release-announcement","/2022/08/08/calldata-tuple-reencoding-head-overflow-bug","/2022/06/15/solidity-0.8.15-release-announcement","/2022/06/15/inline-assembly-memory-side-effects-bug","/2022/06/15/dirty-bytes-array-to-storage-bug","/2022/05/17/solidity-0.8.14-release-announcement","/2022/05/17/data-location-inheritance-bug","/2022/05/17/calldata-reencode-size-check-bug","/2022/05/03/solidity-summit-2022-recap","/2022/04/08/announcing-the-underhanded-contest-winners-2022","/2022/03/16/solidity-0.8.13-release-announcement","/2022/03/16/encodecall-bug","/2022/02/22/solidity-summit-2022-announcement","/2022/02/16/solidity-0.8.12-release-announcement","/2022/02/09/underhanded-solidity-contest-2022-announcement","/2022/02/07/solidity-developer-survey-2021-results","/2021/12/20/solidity-0.8.11-release-announcement","/2021/11/18/solidity-developer-survey-2021","/2021/11/09/solidity-0.8.10-release-announcement","/2021/09/29/user-defined-value-types-bug","/2021/09/29/solidity-0.8.9-release-announcement","/2021/09/29/signed-immutables-bug","/2021/09/27/user-defined-value-types","/2021/09/27/solidity-0.8.8-release-announcement","/2021/08/11/solidity-0.8.7-release-announcement","/2021/06/22/solidity-0.8.6-release-announcement","/2021/06/10/solidity-0.8.5-release-announcement","/2021/05/03/soliditylangorg-umbrella-domain","/2021/04/21/solidity-0.8.4-release-announcement","/2021/04/21/decoding-from-memory-bug","/2021/04/21/custom-errors","/2021/04/01/announcing-solidity-collectibles","/2021/03/23/solidity-0.8.3-release-announcement","/2021/03/23/keccak-optimizer-bug","/2021/03/02/solidity-0.8.2-release-announcement","/2021/03/02/saving-gas-with-simple-inliner","/2021/02/15/contributing-to-solidity-101","/2021/02/10/an-introduction-to-soliditys-fuzz-testing-approach","/2021/02/01/launching-the-solidity-forum","/2021/01/27/solidity-0.8.1-release-announcement","/2021/01/26/solidity-developer-survey-2020-results","/2020/12/16/solidity-v0.8.0-release-announcement","/2020/12/16/solidity-0.7.6-release-announcement","/2020/12/09/solidity-developer-survey-2020","/2020/12/03/solidity-underhanded-contest-winners","/2020/11/18/solidity-0.7.5-release-announcement","/2020/11/04/solidity-ama-1-recap","/2020/10/28/solidity-0.8.x-preview","/2020/10/19/solidity-0.7.4-release-announcement","/2020/10/19/empty-byte-array-copy-bug","/2020/10/07/solidity-dynamic-array-cleanup-bug","/2020/10/07/solidity-0.7.3-release-announcement","/2020/09/28/solidity-0.7.2-release-announcement","/2020/09/21/solidity-underhanded-contest","/2020/09/18/meet-the-team","/2020/09/02/solidity-0.7.1-release-announcement","/2020/07/28/solidity-v0.7.0-release-announcement","/2020/07/22/Solidity-0612-release-announcement","/2020/07/08/solidity-turns-5","/2020/07/07/Solidity-0611-release-announcement","/2020/06/25/sourcify-faq","/2020/06/18/solidity-0.6-inheritance","/2020/06/11/Solidity-0610-release-announcement","/2020/06/09/solidity-summit-recap","/2020/06/05/Solidity-069-release-announcement","/2020/06/02/Sourcify-Towards-Safer-Contract-Interaction-for-Humans","/2020/05/26/array-slices","/2020/05/14/Solidity-068-release-announcement","/2020/05/13/immutable-keyword","/2020/05/04/solidity-0.6.7-release-announcement","/2020/04/17/Solidity-Summit-2020-Goes-Interspace","/2020/04/09/solidity-0.6.6-release-announcement","/2020/04/06/solidity-0.6.5-release-announcement","/2020/04/06/memory-creation-overflow-bug","/2020/03/23/fallback-receive-split","/2020/03/17/solidity-0.5.17-release-announcement","/2020/03/10/solidity-0.6.4-release-announcement","/2020/02/18/solidity-0.6.3-release-announcement","/2020/01/29/solidity-0.6-try-catch","/2020/01/27/solidity-0.6.2-release-announcement","/2020/01/02/solidity-0.6.1-release-announcement","/2020/01/02/solidity-0.5.16-release-announcement","/2019/12/17/solidity-0.6.0-release-announcement","/2019/12/17/solidity-0.5.15-release-announcement","/2019/12/09/solidity-0.5.14-release-announcement","/2019/11/14/solidity-0.5.13-release-announcement","/2019/10/01/solidity-0.5.12-release-announcement","/2019/08/12/solidity-0.5.11-release-announcement","/2019/06/25/solidity-storage-array-bugs","/2019/06/25/solidity-0.5.10-release-announcement","/2019/05/28/solidity-0.5.9-release-announcement","/2019/04/30/solidity-0.5.8-release-announcement","/2019/04/29/solidity-0.4.26-release-announcement","/2019/03/26/solidity-optimizer-and-abiencoderv2-bug","/2019/03/26/solidity-0.5.7-release-announcement","/2019/03/13/solidity-0.5.6-release-announcement","/2019/03/05/solidity-0.5.5-release-announcement","/2019/02/12/solidity-0.5.4-release-announcement","/2019/01/22/solidity-0.5.3-release-announcement","/2018/12/19/solidity-0.5.2-release-announcement","/2018/12/03/solidity-0.5.1-release-announcement","/2018/11/13/solidity-0.5.0-release-announcement","/2018/09/13/solidity-bugfix-release","/2018/09/13/solidity-0.4.25-release-announcement","/2018/05/16/solidity-0.4.24-release-announcement","/2018/04/19/solidity-0.4.23-release-announcement","/2018/04/17/solidity-0.4.22-release-announcement","/2018/03/08/solidity-0.4.21-release-announcement","/2018/02/14/solidity-0.4.20-release-announcement","/2017/11/30/solidity-0.4.19-release-announcement","/2017/10/18/solidity-0.4.18-release-announcement","/2017/09/21/solidity-0.4.17-release-announcement","/2017/08/24/solidity-0.4.16-release-announcement","/2017/08/08/solidity-0.4.15-release-announcement","/2017/07/31/solidity-0.4.14-release-announcement","/2017/07/06/solidity-0.4.13-release-announcement","/2017/07/03/solidity-0.4.12-release-announcement","/2017/05/03/solidity-optimizer-bug","/2017/05/03/solidity-0.4.11-release-announcement","/2017/03/15/solidity-0.4.10-release-announcement","/2017/01/31/solidity-0.4.9-release-announcement","/2017/01/13/solidity-0.4.8-release-announcement","/2016/12/15/solidity-0.4.7-release-announcement","/2016/11/22/solidity-0.4.6-release-announcement","/2016/11/21/solidity-0.4.5-release-announcement","/2016/11/09/analysis-storage-corruption-bug","/2016/11/01/solidity-0.4.4-release-announcement","/2016/11/01/security-alert-solidity-variables-can-overwritten-storage","/2016/10/25/solidity-0.4.3-release-announcement","/2016/09/17/solidity-0.4.2-release-announcement","/2016/09/09/solidity-0.4.1-release-announcement","/2016/09/08/solidity-0.4.0-release-announcement","/2016/09/01/formal-methods-roadmap","/2016/08/10/solidity-0.3.6-release-announcement","/2016/06/10/solidity-0.3.5-release-announcement","/2016/06/10/smart-contract-security","/2016/05/31/solidity-0.3.4-release-announcement","/2016/05/27/solidity-0.3.3-release-announcement","/2016/04/18/solidity-0.3.2-release-announcement","/2016/03/31/solidity-0.3.1-release-announcement","/2016/03/11/solidity-0.3.0-release-announcement","/2016/02/17/solidity-0.2.2-release-announcement","/2016/01/30/solidity-0.2.1-release-announcement","/2015/12/01/solidity-0.2.0-release-announcement","/2015/11/17/solidity-0.1.7-release-announcement","/2015/10/16/solidity-0.1.6-release-announcement","/2015/10/07/solidity-0.1.5-release-announcement","/2015/09/30/solidity-0.1.4-release-announcement","/2015/09/22/solidity-0.1.3-release-announcement","/2015/08/21/solidity-0.1.2-release-announcement"]},"__N_SSG":true}