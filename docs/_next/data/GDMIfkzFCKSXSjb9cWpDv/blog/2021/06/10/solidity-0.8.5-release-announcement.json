{"pageProps":{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.8.5 Release Announcement","date":"2021-06-10","author":"Solidity Team","category":"Releases"},"content":"\n[Solidity v0.8.5](https://github.com/ethereum/solidity/releases/tag/v0.8.5) allows conversions\nfrom `bytes` to `bytesNN` values, adds the `verbatim` builtin function to inject\narbitrary bytecode in Yul and fixes several smaller bugs.\n\n## Notable New Features\n\n### Bytes Conversion\n\n_Find the complete feature documentation [here](https://docs.soliditylang.org/en/v0.8.5/types.html#explicit-conversions)._\n\nThis release introduces the ability to convert `bytes` and `bytes` slices to fixed bytes types `bytes1` / ... / `bytes32`. While conversion between fixed-length bytes types has always been possible, it is now also possible to convert dynamically-sized bytes types to fixed-length bytes types.\n\nIn case a byte array is longer than the target fixed bytes type, it will be truncated at the end:\n\n```solidity\nfunction f(bytes memory c) public pure returns (bytes8) {\n\t// If c is longer than 8 bytes, truncation happens\n\treturn bytes8(c);\n}\n```\n\nCalling `f(\"12345678\")` in Solidity code will return `\"12345678\"`, as will calling it as `f(\"1234567890\")`.\nIf the array is shorter than the target fixed type, it will be padded with zeros at the end, so\ncalling `f(\"1234\")` will return `\"1234\"`.\n\nA nice example of using the `bytes` conversion feature would be its application in proxies:\n\n```solidity\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.5;\ncontract Proxy {\n\t/// @dev Address of the client contract managed by this proxy\n\taddress client;\n\tconstructor(address _client) {\n\t\tclient = _client;\n\t}\n\t/// Forwards all calls to the client but performs additional checks for calls to \"setOwner(address)\".\n\tfunction forward(bytes calldata _payload) external {\n\t\trequire(_payload.length >= 4);\n\t\tbytes4 sig = bytes4(_payload[:4]);\n\t\tif (sig == bytes4(keccak256(\"setOwner(address)\"))) {\n\t\t\taddress owner = abi.decode(_payload[4:], (address));\n\t\t\trequire(owner != address(0), \"Address of owner cannot be zero.\");\n\t\t}\n\t\t(bool status,) = client.delegatecall(_payload);\n\t\trequire(status, \"Forwarded call failed.\");\n\t}\n}\n```\n\nBefore, it was not possible to do `bytes4 sig = bytes4(_payload[:4]);`, instead you had to use the following:\n\n```solidity\nbytes4 sig =\n\t_payload[0] |\n\t(bytes4(_payload[1]) >> 8) |\n\t(bytes4(_payload[2]) >> 16) |\n\t(bytes4(_payload[3]) >> 24);\n```\n\n### `Verbatim` in Yul\n\n_Find the complete feature documentation [here](https://docs.soliditylang.org/en/v0.8.5/yul.html#verbatim)._\n\nThis release introduces the set of `verbatim` builtin functions for Yul that allows you inject\narbitrary bytecode into the binary. This is currently only available via pure Yul, i.e., it is not\naccessible via inline assembly.\n\nThis essentially has two use-cases (more on those below):\n\n1. The use of opcodes unknown to Yul (because they are only proposed or because you are targeting an EVM-incompatible chain).\n2. Generation of specific sequences of bytecode that are unmodified by the optimizer.\n\nThe functions are `verbatim<n>i_<m>o(\"<data>\", ...)`, where\n\n- `n` is a decimal between 0 and 99 that specifies the number of input stack slots / variables,\n- `m` is a decimal between 0 and 99 that specifies the number of output stack slots / variables,\n- `data` is a string literal that contains the sequence of bytes.\n\nNote that there are some caveats when it comes to using `verbatim`. Details about it can be found in\nthe [documentation](https://docs.soliditylang.org/en/v0.8.5/yul.html#verbatim).\n\n#### Using new Opcodes\n\nAs a practical example, one can use this to conveniently inject a newly proposed EVM opcode into the\nbinary. Take the proposed `BASEFEE` (at `0x48`) opcode (see [EIP-3198][1] and [EIP-1559][2]), since\nthe Solidity compiler currently does not support this opcode, one can use `verbatim` to implement it\nin Yul.\n\n```solidity\n{\n\tfunction basefee() -> out {\n\t\tout := verbatim_0i_1o(hex\"48\")\n\t}\n\n\tsstore(0, basefee())\n}\n```\n\nHere's another example that has an input parameter for `verbatim`.\n\n```solidity\nlet x := calldataload(0)\n// The hex\"600202\" corresponds to EVM instructions:\n// PUSH 02 MUL\n// That is, it multiplies x by 2.\nlet double := verbatim_1i_1o(hex\"600202\", x)\n```\n\nThe above code will result in a `dup1` opcode to retrieve `x` (the optimizer may directly use the\nresult of the `calldataload` opcode, though) directly followed by `600202`. The code is assumed to\nconsume the (copied) value of `x` and produce the result on the top of the stack. The compiler then\ngenerates code to allocate a stack slot for `double` and store the result there.\n\n#### Use-Case for Optimism\n\nThe second use-case can be useful for Layer-2-solutions like Optimism, but also other situations\nlike bytecode analysis or debugging come to mind. Optimism currently uses a custom Solidity compiler\nbecause they simulate the execution of a smart contract where every change to the state\n(storage, external calls, etc.) is not executed directly, but it is replaced by a call to\na manager contract that stores the change for verification. The problem with this is checking\nwhether or not a contract conforms to these restrictions (i.e. properly calls the manager contract\nfor each change), especially since this has to be done by the on-chain fraud detection mechanism.\nWhat they do is that they check that none of the state-changing opcodes is used by the contract, with the\nexception of the `call` opcode that calls the manager contract. For this exception to be\nproperly detected, the sequence of opcodes that leads to this `call` opcode has to have a specific\nform and usually, the Solidity optimizer does some rearranging and destroys this form.\nLuckily, `verbatim` can solve this problem such that Optimism does not need to rely on a custom\nSolidity compiler anymore and can use all later versions of the Solidity compiler without modifications.\n\nThe optimism compiler could take the Yul code generated by the Solidity compiler, append the following\nYul helper functions and syntactically replace all state-changing builtin function calls\nwith their `ovm_`-counterparts. For example, all `sstore(x, y)` calls are relpaced by\n`ovm_sstore(x, y)` calls. After this replacement, the Yul optimizer can even be run again.\n(This code only illustrates `sstore`.)\n\n```solidity\n/// Generic call to the manager contract.\nfunction ovm_callManager(arguments, arguments_size, output_area, output_area_size) {\n\tverbatim_4i_0o(\n\t\thex\"336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b\",\n\t\targuments,\n\t\targuments_size,\n\t\toutput_area,\n\t\toutput_area_size\n\t)\n}\n\n// Call a manager function with two arguments\nfunction ovm_kall_2i(signature, x, y) {\n\t// Store touched memory in locals and restore it at the end.\n\tlet tmp_a := mload(0x00)\n\tlet tmp_b := mload(0x20)\n\tlet tmp_c := mload(0x40)\n\tmstore(0, signature)\n\tmstore(4, x)\n\tmstore(0x24, y)\n\tovm_callManager(0, 0x44, 0, 0)\n\tmstore(0x00, tmp_a)\n\tmstore(0x20, tmp_b)\n\tmstore(0x40, tmp_c)\n}\n\n// Replace all calls to ``sstore(x, y)`` by ``ovm_sstore(x, y)``\nfunction ovm_sstore(x, y) {\n\t// The hex code is the selector of\n\t// the sstore function on the manager contract.\n\tovm_kall_2i(hex\"22bd64c0\", x, y)\n}\n\n```\n\n## Full Changelog\n\n### Language Features:\n\n- Allowing conversion from `bytes` and `bytes` slices to `bytes1`/.../`bytes32`.\n- Yul: Add `verbatim` builtin function to inject arbitrary bytecode.\n\n### Compiler Features:\n\n- Code Generator: Insert helper functions for panic codes instead of inlining unconditionally. This can reduce costs if many panics (checks) are inserted, but can increase costs where few panics are used.\n- EVM: Set the default EVM version to \"Berlin\".\n- SMTChecker: Function definitions can be annotated with the custom Natspec tag `custom:smtchecker abstract-function-nondet` to be abstracted by a nondeterministic value when called.\n- Standard JSON / combined JSON: New artifact \"functionDebugData\" that contains bytecode offsets of entry points of functions and potentially more information in the future.\n- Yul Optimizer: Evaluate `keccak256(a, c)`, when the value at memory location `a` is known at compile time and `c` is a constant `<= 32`.\n\n### Bugfixes:\n\n- AST: Do not output value of Yul literal if it is not a valid UTF-8 string.\n- Code Generator: Fix internal error when function arrays are assigned to storage variables and the function types can be implicitly converted but are not identical.\n- Code Generator: Fix internal error when super would have to skip an unimplemented function in the virtual resolution order.\n- Control Flow Graph: Assume unimplemented modifiers use a placeholder.\n- Control Flow Graph: Take internal calls to functions that always revert into account for reporting unused or unassigned variables.\n- Function Call Graph: Fix internal error connected with circular constant references.\n- Name Resolver: Do not issue shadowing warning if the shadowing name is not directly accessible.\n- Natspec: Allow multiple `@return` tags on public state variable documentation.\n- SMTChecker: Fix internal error on conversion from `bytes` to `fixed bytes`.\n- SMTChecker: Fix internal error on external calls from the constructor.\n- SMTChecker: Fix internal error on struct constructor with fixed bytes member initialized with string literal.\n- Source Locations: Properly set source location of scoped blocks.\n- Standard JSON: Properly allow the `inliner` setting under `settings.optimizer.details`.\n- Type Checker: Fix internal compiler error related to having mapping types in constructor parameter for abstract contracts.\n- Type Checker: Fix internal compiler error when attempting to use an invalid external function type on pre-byzantium EVMs.\n- Type Checker: Fix internal compiler error when overriding receive ether function with one having different parameters during inheritance.\n- Type Checker: Make errors about (nested) mapping type in event or error parameter into fatal type errors.\n\n### AST Changes:\n\n- Add member `hexValue` for Yul string and hex literals.\n\nA big thank you to all contributors who helped make this release possible!\n\nDownload the new version of Solidity [here](https://github.com/ethereum/solidity/releases/tag/v0.8.5).\n\n[1]: https://eips.ethereum.org/EIPS/eip-3198\n[2]: https://eips.ethereum.org/EIPS/eip-1559\n","availableURLs":["/2023/05/10/solidity-0.8.20-release-announcement","/2023/03/10/solidity-developer-survey-2022-results","/2023/02/22/user-defined-operators","/2023/02/22/solidity-0.8.19-release-announcement","/2023/02/01/solidity-0.8.18-release-announcement","/2022/12/07/solidity-developer-survey-2022-announcement","/2022/12/05/solidity-core-team-updates","/2022/09/08/storage-write-removal-before-conditional-termination","/2022/09/08/solidity-0.8.17-release-announcement","/2022/08/08/solidity-0.8.16-release-announcement","/2022/08/08/calldata-tuple-reencoding-head-overflow-bug","/2022/06/15/solidity-0.8.15-release-announcement","/2022/06/15/inline-assembly-memory-side-effects-bug","/2022/06/15/dirty-bytes-array-to-storage-bug","/2022/05/17/solidity-0.8.14-release-announcement","/2022/05/17/data-location-inheritance-bug","/2022/05/17/calldata-reencode-size-check-bug","/2022/05/03/solidity-summit-2022-recap","/2022/04/08/announcing-the-underhanded-contest-winners-2022","/2022/03/16/solidity-0.8.13-release-announcement","/2022/03/16/encodecall-bug","/2022/02/22/solidity-summit-2022-announcement","/2022/02/16/solidity-0.8.12-release-announcement","/2022/02/09/underhanded-solidity-contest-2022-announcement","/2022/02/07/solidity-developer-survey-2021-results","/2021/12/20/solidity-0.8.11-release-announcement","/2021/11/18/solidity-developer-survey-2021","/2021/11/09/solidity-0.8.10-release-announcement","/2021/09/29/user-defined-value-types-bug","/2021/09/29/solidity-0.8.9-release-announcement","/2021/09/29/signed-immutables-bug","/2021/09/27/user-defined-value-types","/2021/09/27/solidity-0.8.8-release-announcement","/2021/08/11/solidity-0.8.7-release-announcement","/2021/06/22/solidity-0.8.6-release-announcement","/2021/06/10/solidity-0.8.5-release-announcement","/2021/05/03/soliditylangorg-umbrella-domain","/2021/04/21/solidity-0.8.4-release-announcement","/2021/04/21/decoding-from-memory-bug","/2021/04/21/custom-errors","/2021/04/01/announcing-solidity-collectibles","/2021/03/23/solidity-0.8.3-release-announcement","/2021/03/23/keccak-optimizer-bug","/2021/03/02/solidity-0.8.2-release-announcement","/2021/03/02/saving-gas-with-simple-inliner","/2021/02/15/contributing-to-solidity-101","/2021/02/10/an-introduction-to-soliditys-fuzz-testing-approach","/2021/02/01/launching-the-solidity-forum","/2021/01/27/solidity-0.8.1-release-announcement","/2021/01/26/solidity-developer-survey-2020-results","/2020/12/16/solidity-v0.8.0-release-announcement","/2020/12/16/solidity-0.7.6-release-announcement","/2020/12/09/solidity-developer-survey-2020","/2020/12/03/solidity-underhanded-contest-winners","/2020/11/18/solidity-0.7.5-release-announcement","/2020/11/04/solidity-ama-1-recap","/2020/10/28/solidity-0.8.x-preview","/2020/10/19/solidity-0.7.4-release-announcement","/2020/10/19/empty-byte-array-copy-bug","/2020/10/07/solidity-dynamic-array-cleanup-bug","/2020/10/07/solidity-0.7.3-release-announcement","/2020/09/28/solidity-0.7.2-release-announcement","/2020/09/21/solidity-underhanded-contest","/2020/09/18/meet-the-team","/2020/09/02/solidity-0.7.1-release-announcement","/2020/07/28/solidity-v0.7.0-release-announcement","/2020/07/22/Solidity-0612-release-announcement","/2020/07/08/solidity-turns-5","/2020/07/07/Solidity-0611-release-announcement","/2020/06/25/sourcify-faq","/2020/06/18/solidity-0.6-inheritance","/2020/06/11/Solidity-0610-release-announcement","/2020/06/09/solidity-summit-recap","/2020/06/05/Solidity-069-release-announcement","/2020/06/02/Sourcify-Towards-Safer-Contract-Interaction-for-Humans","/2020/05/26/array-slices","/2020/05/14/Solidity-068-release-announcement","/2020/05/13/immutable-keyword","/2020/05/04/solidity-0.6.7-release-announcement","/2020/04/17/Solidity-Summit-2020-Goes-Interspace","/2020/04/09/solidity-0.6.6-release-announcement","/2020/04/06/solidity-0.6.5-release-announcement","/2020/04/06/memory-creation-overflow-bug","/2020/03/23/fallback-receive-split","/2020/03/17/solidity-0.5.17-release-announcement","/2020/03/10/solidity-0.6.4-release-announcement","/2020/02/18/solidity-0.6.3-release-announcement","/2020/01/29/solidity-0.6-try-catch","/2020/01/27/solidity-0.6.2-release-announcement","/2020/01/02/solidity-0.6.1-release-announcement","/2020/01/02/solidity-0.5.16-release-announcement","/2019/12/17/solidity-0.6.0-release-announcement","/2019/12/17/solidity-0.5.15-release-announcement","/2019/12/09/solidity-0.5.14-release-announcement","/2019/11/14/solidity-0.5.13-release-announcement","/2019/10/01/solidity-0.5.12-release-announcement","/2019/08/12/solidity-0.5.11-release-announcement","/2019/06/25/solidity-storage-array-bugs","/2019/06/25/solidity-0.5.10-release-announcement","/2019/05/28/solidity-0.5.9-release-announcement","/2019/04/30/solidity-0.5.8-release-announcement","/2019/04/29/solidity-0.4.26-release-announcement","/2019/03/26/solidity-optimizer-and-abiencoderv2-bug","/2019/03/26/solidity-0.5.7-release-announcement","/2019/03/13/solidity-0.5.6-release-announcement","/2019/03/05/solidity-0.5.5-release-announcement","/2019/02/12/solidity-0.5.4-release-announcement","/2019/01/22/solidity-0.5.3-release-announcement","/2018/12/19/solidity-0.5.2-release-announcement","/2018/12/03/solidity-0.5.1-release-announcement","/2018/11/13/solidity-0.5.0-release-announcement","/2018/09/13/solidity-bugfix-release","/2018/09/13/solidity-0.4.25-release-announcement","/2018/05/16/solidity-0.4.24-release-announcement","/2018/04/19/solidity-0.4.23-release-announcement","/2018/04/17/solidity-0.4.22-release-announcement","/2018/03/08/solidity-0.4.21-release-announcement","/2018/02/14/solidity-0.4.20-release-announcement","/2017/11/30/solidity-0.4.19-release-announcement","/2017/10/18/solidity-0.4.18-release-announcement","/2017/09/21/solidity-0.4.17-release-announcement","/2017/08/24/solidity-0.4.16-release-announcement","/2017/08/08/solidity-0.4.15-release-announcement","/2017/07/31/solidity-0.4.14-release-announcement","/2017/07/06/solidity-0.4.13-release-announcement","/2017/07/03/solidity-0.4.12-release-announcement","/2017/05/03/solidity-optimizer-bug","/2017/05/03/solidity-0.4.11-release-announcement","/2017/03/15/solidity-0.4.10-release-announcement","/2017/01/31/solidity-0.4.9-release-announcement","/2017/01/13/solidity-0.4.8-release-announcement","/2016/12/15/solidity-0.4.7-release-announcement","/2016/11/22/solidity-0.4.6-release-announcement","/2016/11/21/solidity-0.4.5-release-announcement","/2016/11/09/analysis-storage-corruption-bug","/2016/11/01/solidity-0.4.4-release-announcement","/2016/11/01/security-alert-solidity-variables-can-overwritten-storage","/2016/10/25/solidity-0.4.3-release-announcement","/2016/09/17/solidity-0.4.2-release-announcement","/2016/09/09/solidity-0.4.1-release-announcement","/2016/09/08/solidity-0.4.0-release-announcement","/2016/09/01/formal-methods-roadmap","/2016/08/10/solidity-0.3.6-release-announcement","/2016/06/10/solidity-0.3.5-release-announcement","/2016/06/10/smart-contract-security","/2016/05/31/solidity-0.3.4-release-announcement","/2016/05/27/solidity-0.3.3-release-announcement","/2016/04/18/solidity-0.3.2-release-announcement","/2016/03/31/solidity-0.3.1-release-announcement","/2016/03/11/solidity-0.3.0-release-announcement","/2016/02/17/solidity-0.2.2-release-announcement","/2016/01/30/solidity-0.2.1-release-announcement","/2015/12/01/solidity-0.2.0-release-announcement","/2015/11/17/solidity-0.1.7-release-announcement","/2015/10/16/solidity-0.1.6-release-announcement","/2015/10/07/solidity-0.1.5-release-announcement","/2015/09/30/solidity-0.1.4-release-announcement","/2015/09/22/solidity-0.1.3-release-announcement","/2015/08/21/solidity-0.1.2-release-announcement"]},"__N_SSG":true}