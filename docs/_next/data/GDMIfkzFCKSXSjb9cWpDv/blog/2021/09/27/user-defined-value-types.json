{"pageProps":{"frontmatter":{"layout":"post","published":true,"title":"User Defined Value Types in Solidity","date":"2021-09-27","author":"Solidity Team","category":"Explainers"},"content":"\n[Solidity v0.8.8](https://github.com/ethereum/solidity/releases/tag/v0.8.8) introduces [user defined\nvalue types](https://docs.soliditylang.org/en/latest/types.html?#user-defined-value-types) as a\nmeans to create zero-cost abstractions over an elementary value type that also increases type safety\nand improves readability.\n\n## Motivation\n\nA problem with primitive value types is that they are not very descriptive: they only specify how\nthe data is stored and not how it should be interpreted. For example, one may want to use `uint128`\nto store the price of some object as well as the quantity available. It is quite useful to have\nstricter type rules to avoid intermingling of the two different concepts. For example, one may want\nto disallow assigning a quantity to a price or vice versa.\n\nOne option for solving this issue is by using\n[structs](https://docs.soliditylang.org/en/latest/types.html#structs). For example, price and\nquantity can be abstracted as structs as follows:\n\n```solidity\nstruct Price { uint128 price; }\nstruct Quantity { uint128 quantity; }\n\nfunction toPrice(uint128 price) returns(Price memory) {\n    return Price(price);\n}\nfunction fromPrice(Price memory price) returns(uint128) {\n   return price.price;\n}\nfunction toQuantity(uint128 quantity) returns(Quantity memory) {\n    return Quantity(quantity);\n}\nfunction fromQuantity(Quantity memory quantity) returns(uint128) {\n    return quantity.quantity;\n}\n```\n\nHowever, a [struct](https://docs.soliditylang.org/en/latest/types.html?#structs) is a reference type\nand therefore always points to a value in `memory`, `calldata` or `storage`. This means that the\nabove abstraction has a runtime overhead, i.e., additional gas when compared to using just `uint128`\nto represent the underlying value. In particular, the functions `toPrice` and `toQuantity` involve\nstoring the value in memory. Similarly, the functions `fromPrice` and `fromQuantity` read the\nrespective value from memory. Together, these functions pass the value from `stack -> memory ->\nstack` which wastes memory and incurs a runtime cost. This issue is solved by user defined value\ntypes, which are abstractions of elementary value types (such as `uint8` or `address`), without any\nadditional runtime overhead.\n\n## Syntax for User Defined Value Types\n\nA user defined value type is defined using `type C is V;`, where `C` is the name of the newly\nintroduced type and `V` has to be a built-in value type (the \"underlying type\"). They can be defined\ninside or outside contracts (including libraries and interfaces). The function `C.wrap` is used to\nconvert from the underlying type to the custom type. Similarly, the function `C.unwrap` is used to\nconvert from the custom type to the underlying type.\n\nGoing back to the problem from the [motivation](#motivation) section, one can replace the structs by:\n\n```solidity\npragma solidity ^0.8.8;\n\ntype Price is uint128;\ntype Quantity is uint128;\n```\n\nThe functions `toPrice` and `toQuantity` can be replaced by `Price.wrap` and `Quantity.wrap`\nrespectively. Similarly, the functions `fromPrice` and `fromQuantity` can be replaced by\n`Price.unwrap` and `Quantity.unwrap` respectively.\n\nThe data-representation of the values of such types are inherited from the underlying type and the\nunderlying type is also used in the ABI. This means that the following two `transfer` functions\nwould be identical, i.e., they have the same [function\nselector](https://docs.soliditylang.org/en/latest/abi-spec.html#function-selector) as well as the\nsame [ABI encoding and\ndecoding](https://docs.soliditylang.org/en/latest/abi-spec.html#mapping-solidity-to-abi-types). This\nallows using user defined value types in a backwards compatible way.\n\n```solidity\npragma solidity ^0.8.8;\n\ntype Decimal18 is uint256;\n\ninterface MinimalERC20 {\n    function transfer(address to, Decimal18 value) external;\n}\n\ninterface AnotherMinimalERC20 {\n    function transfer(address to, uint256 value) external;\n}\n```\n\nNotice in the above example, how the user defined type `Decimal18` makes it clear that a value is\nsupposed to represent a number with 18 decimals.\n\n## Example\n\nThe following example illustrates a custom type `UFixed` representing a decimal fixed point type\nwith 18 decimals and a minimal library to do arithmetic operations on the type.\n\n```solidity\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.8;\n\n// Represent a 18 decimal, 256 bit wide fixed point type\n// using a user defined value type.\ntype UFixed is uint256;\n\n/// A minimal library to do fixed point operations on UFixed.\nlibrary FixedMath {\n    uint constant multiplier = 10**18;\n\n    /// Adds two UFixed numbers. Reverts on overflow,\n    /// relying on checked arithmetic on uint256.\n    function add(UFixed a, UFixed b) internal pure returns (UFixed) {\n        return UFixed.wrap(UFixed.unwrap(a) + UFixed.unwrap(b));\n    }\n    /// Multiplies UFixed and uint256. Reverts on overflow,\n    /// relying on checked arithmetic on uint256.\n    function mul(UFixed a, uint256 b) internal pure returns (UFixed) {\n        return UFixed.wrap(UFixed.unwrap(a) * b);\n    }\n    /// Take the floor of a UFixed number.\n    /// @return the largest integer that does not exceed `a`.\n    function floor(UFixed a) internal pure returns (uint256) {\n        return UFixed.unwrap(a) / multiplier;\n    }\n    /// Turns a uint256 into a UFixed of the same value.\n    /// Reverts if the integer is too large.\n    function toUFixed(uint256 a) internal pure returns (UFixed) {\n        return UFixed.wrap(a * multiplier);\n    }\n}\n```\n\nNotice how `UFixed.wrap` and `FixedMath.toUFixed` have the same signature but perform two very\ndifferent operations: The `UFixed.wrap` function returns a `UFixed` that has the same data\nrepresentation as the input, whereas `toUFixed` returns a `UFixed` that has the same numerical\nvalue. One can allow some form of type-encapsulation by only using the `wrap` and `unwrap` functions\nin the file that defines the type.\n\n## Operators and Type Rules\n\nExplicit and implicit conversions to and from other types are disallowed.\n\nCurrently, no operators are defined for user defined value types. In particular, even the operator\n`==` is not defined. However, allowing operators is currently being discussed. To give a short\noutlook on the applications, one may want to introduce a new integer type that always does wrapping\narithmetic as follows:\n\n```solidity\n/// Proposal on defining operators on user defined value types\n/// Note: this does not fully compile on Solidity 0.8.8; only a concept.\n\ntype UncheckedInt8 is int8;\n\nfunction add(UncheckedInt8 a, UncheckedInt8 b) pure returns(UncheckedInt8) {\n    unchecked {\n        return UncheckedInt8.wrap(UncheckedInt8.unwrap(a) + UncheckedInt8.unwrap(b));\n    }\n}\nfunction addInt(UncheckedInt8 a, uint b) pure returns(UncheckedInt8) {\n    unchecked {\n        return UncheckedInt8.wrap(UncheckedInt8.unwrap(a) + b);\n    }\n}\n\nusing {add as +, addInt as +} for UncheckedInt8;\n\ncontract MockOperator {\n    UncheckedInt8 x;\n    function increment() external {\n        // This would not revert on overflow when x = 127\n        x = x + 1;\n    }\n    function add(UncheckedInt8 y) external {\n        // Similarly, this would also not revert on overflow.\n        x = x + y;\n    }\n}\n```\n\nYou can join or follow this discussion in the [Solidity\nforum](https://forum.soliditylang.org/t/user-defined-types-and-operators/456) and [issue\n#11969](https://github.com/ethereum/solidity/issues/11969). Also, you can join or follow the\ndiscussion about allowing the constructor syntax for user defined value types in the [issue\n#11953](https://github.com/ethereum/solidity/issues/11953).\n","availableURLs":["/2023/05/10/solidity-0.8.20-release-announcement","/2023/03/10/solidity-developer-survey-2022-results","/2023/02/22/user-defined-operators","/2023/02/22/solidity-0.8.19-release-announcement","/2023/02/01/solidity-0.8.18-release-announcement","/2022/12/07/solidity-developer-survey-2022-announcement","/2022/12/05/solidity-core-team-updates","/2022/09/08/storage-write-removal-before-conditional-termination","/2022/09/08/solidity-0.8.17-release-announcement","/2022/08/08/solidity-0.8.16-release-announcement","/2022/08/08/calldata-tuple-reencoding-head-overflow-bug","/2022/06/15/solidity-0.8.15-release-announcement","/2022/06/15/inline-assembly-memory-side-effects-bug","/2022/06/15/dirty-bytes-array-to-storage-bug","/2022/05/17/solidity-0.8.14-release-announcement","/2022/05/17/data-location-inheritance-bug","/2022/05/17/calldata-reencode-size-check-bug","/2022/05/03/solidity-summit-2022-recap","/2022/04/08/announcing-the-underhanded-contest-winners-2022","/2022/03/16/solidity-0.8.13-release-announcement","/2022/03/16/encodecall-bug","/2022/02/22/solidity-summit-2022-announcement","/2022/02/16/solidity-0.8.12-release-announcement","/2022/02/09/underhanded-solidity-contest-2022-announcement","/2022/02/07/solidity-developer-survey-2021-results","/2021/12/20/solidity-0.8.11-release-announcement","/2021/11/18/solidity-developer-survey-2021","/2021/11/09/solidity-0.8.10-release-announcement","/2021/09/29/user-defined-value-types-bug","/2021/09/29/solidity-0.8.9-release-announcement","/2021/09/29/signed-immutables-bug","/2021/09/27/user-defined-value-types","/2021/09/27/solidity-0.8.8-release-announcement","/2021/08/11/solidity-0.8.7-release-announcement","/2021/06/22/solidity-0.8.6-release-announcement","/2021/06/10/solidity-0.8.5-release-announcement","/2021/05/03/soliditylangorg-umbrella-domain","/2021/04/21/solidity-0.8.4-release-announcement","/2021/04/21/decoding-from-memory-bug","/2021/04/21/custom-errors","/2021/04/01/announcing-solidity-collectibles","/2021/03/23/solidity-0.8.3-release-announcement","/2021/03/23/keccak-optimizer-bug","/2021/03/02/solidity-0.8.2-release-announcement","/2021/03/02/saving-gas-with-simple-inliner","/2021/02/15/contributing-to-solidity-101","/2021/02/10/an-introduction-to-soliditys-fuzz-testing-approach","/2021/02/01/launching-the-solidity-forum","/2021/01/27/solidity-0.8.1-release-announcement","/2021/01/26/solidity-developer-survey-2020-results","/2020/12/16/solidity-v0.8.0-release-announcement","/2020/12/16/solidity-0.7.6-release-announcement","/2020/12/09/solidity-developer-survey-2020","/2020/12/03/solidity-underhanded-contest-winners","/2020/11/18/solidity-0.7.5-release-announcement","/2020/11/04/solidity-ama-1-recap","/2020/10/28/solidity-0.8.x-preview","/2020/10/19/solidity-0.7.4-release-announcement","/2020/10/19/empty-byte-array-copy-bug","/2020/10/07/solidity-dynamic-array-cleanup-bug","/2020/10/07/solidity-0.7.3-release-announcement","/2020/09/28/solidity-0.7.2-release-announcement","/2020/09/21/solidity-underhanded-contest","/2020/09/18/meet-the-team","/2020/09/02/solidity-0.7.1-release-announcement","/2020/07/28/solidity-v0.7.0-release-announcement","/2020/07/22/Solidity-0612-release-announcement","/2020/07/08/solidity-turns-5","/2020/07/07/Solidity-0611-release-announcement","/2020/06/25/sourcify-faq","/2020/06/18/solidity-0.6-inheritance","/2020/06/11/Solidity-0610-release-announcement","/2020/06/09/solidity-summit-recap","/2020/06/05/Solidity-069-release-announcement","/2020/06/02/Sourcify-Towards-Safer-Contract-Interaction-for-Humans","/2020/05/26/array-slices","/2020/05/14/Solidity-068-release-announcement","/2020/05/13/immutable-keyword","/2020/05/04/solidity-0.6.7-release-announcement","/2020/04/17/Solidity-Summit-2020-Goes-Interspace","/2020/04/09/solidity-0.6.6-release-announcement","/2020/04/06/solidity-0.6.5-release-announcement","/2020/04/06/memory-creation-overflow-bug","/2020/03/23/fallback-receive-split","/2020/03/17/solidity-0.5.17-release-announcement","/2020/03/10/solidity-0.6.4-release-announcement","/2020/02/18/solidity-0.6.3-release-announcement","/2020/01/29/solidity-0.6-try-catch","/2020/01/27/solidity-0.6.2-release-announcement","/2020/01/02/solidity-0.6.1-release-announcement","/2020/01/02/solidity-0.5.16-release-announcement","/2019/12/17/solidity-0.6.0-release-announcement","/2019/12/17/solidity-0.5.15-release-announcement","/2019/12/09/solidity-0.5.14-release-announcement","/2019/11/14/solidity-0.5.13-release-announcement","/2019/10/01/solidity-0.5.12-release-announcement","/2019/08/12/solidity-0.5.11-release-announcement","/2019/06/25/solidity-storage-array-bugs","/2019/06/25/solidity-0.5.10-release-announcement","/2019/05/28/solidity-0.5.9-release-announcement","/2019/04/30/solidity-0.5.8-release-announcement","/2019/04/29/solidity-0.4.26-release-announcement","/2019/03/26/solidity-optimizer-and-abiencoderv2-bug","/2019/03/26/solidity-0.5.7-release-announcement","/2019/03/13/solidity-0.5.6-release-announcement","/2019/03/05/solidity-0.5.5-release-announcement","/2019/02/12/solidity-0.5.4-release-announcement","/2019/01/22/solidity-0.5.3-release-announcement","/2018/12/19/solidity-0.5.2-release-announcement","/2018/12/03/solidity-0.5.1-release-announcement","/2018/11/13/solidity-0.5.0-release-announcement","/2018/09/13/solidity-bugfix-release","/2018/09/13/solidity-0.4.25-release-announcement","/2018/05/16/solidity-0.4.24-release-announcement","/2018/04/19/solidity-0.4.23-release-announcement","/2018/04/17/solidity-0.4.22-release-announcement","/2018/03/08/solidity-0.4.21-release-announcement","/2018/02/14/solidity-0.4.20-release-announcement","/2017/11/30/solidity-0.4.19-release-announcement","/2017/10/18/solidity-0.4.18-release-announcement","/2017/09/21/solidity-0.4.17-release-announcement","/2017/08/24/solidity-0.4.16-release-announcement","/2017/08/08/solidity-0.4.15-release-announcement","/2017/07/31/solidity-0.4.14-release-announcement","/2017/07/06/solidity-0.4.13-release-announcement","/2017/07/03/solidity-0.4.12-release-announcement","/2017/05/03/solidity-optimizer-bug","/2017/05/03/solidity-0.4.11-release-announcement","/2017/03/15/solidity-0.4.10-release-announcement","/2017/01/31/solidity-0.4.9-release-announcement","/2017/01/13/solidity-0.4.8-release-announcement","/2016/12/15/solidity-0.4.7-release-announcement","/2016/11/22/solidity-0.4.6-release-announcement","/2016/11/21/solidity-0.4.5-release-announcement","/2016/11/09/analysis-storage-corruption-bug","/2016/11/01/solidity-0.4.4-release-announcement","/2016/11/01/security-alert-solidity-variables-can-overwritten-storage","/2016/10/25/solidity-0.4.3-release-announcement","/2016/09/17/solidity-0.4.2-release-announcement","/2016/09/09/solidity-0.4.1-release-announcement","/2016/09/08/solidity-0.4.0-release-announcement","/2016/09/01/formal-methods-roadmap","/2016/08/10/solidity-0.3.6-release-announcement","/2016/06/10/solidity-0.3.5-release-announcement","/2016/06/10/smart-contract-security","/2016/05/31/solidity-0.3.4-release-announcement","/2016/05/27/solidity-0.3.3-release-announcement","/2016/04/18/solidity-0.3.2-release-announcement","/2016/03/31/solidity-0.3.1-release-announcement","/2016/03/11/solidity-0.3.0-release-announcement","/2016/02/17/solidity-0.2.2-release-announcement","/2016/01/30/solidity-0.2.1-release-announcement","/2015/12/01/solidity-0.2.0-release-announcement","/2015/11/17/solidity-0.1.7-release-announcement","/2015/10/16/solidity-0.1.6-release-announcement","/2015/10/07/solidity-0.1.5-release-announcement","/2015/09/30/solidity-0.1.4-release-announcement","/2015/09/22/solidity-0.1.3-release-announcement","/2015/08/21/solidity-0.1.2-release-announcement"]},"__N_SSG":true}