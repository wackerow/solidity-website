{"pageProps":{"frontmatter":{"layout":"post","published":true,"title":"All you need to know about Sourcify","date":"2020-06-25","author":"Franziska Heintel","category":"Explainers"},"content":"\nWelcome to Sourcify's first short FAQ! If your questions around source verification haven't been answered after reading\nthis post, please feel free to drop by the [Sourcify Gitter channel](https://gitter.im/ethereum/source-verify) and ask us\nany question there. Also stay tuned on more turorials and developer focused content to follow here and on the [Remix blog](https://medium.com/remix-ide)!\n\n## Source Verification\n\n### What is source verification?\n\nSolidity contract source code can be verified by checking whether the on-chain deployed code\nis matching with published source code files. In order to allow for source verification,\nthe source and metadata files need to be published, thus enabling developers to verify that the deployed bytecode is an exact match to the\npublished files. By doing so, it can be verified that the contract code is exactly the same as when it was deployed on the\nblockchain and has not been adjusted or tampered with before deploying it.\n\n### Why is source verification important?\n\nWithout open source contracts it is hard to tell what the application you are using will actually be doing.\nOne of the decentralized web's biggest aspirations is to build a trustless infrastructure, aiming to reduce the need to\ntrust third parties and service providers and decreasing censorship opportunities. It should, by design, not be required to\n\"blindly\" trust a dapp developer or web3 project. It should always be possible to verify it for yourself,\nor if you're not tech-savvy enough, leverage the power of the crowd of other developers who can look at and call\nout malicious code once it's open source.\n\n### Why should I publish my source code / open-source it?\n\nClosed source contract code cannot easily be verified since the trustless setup is not maintained if you have to rely\non a third party which verifies the code for you. In that scenario, the verification service providers could be an attack\nvector and would need to be trusted.\n\n## Metadata\n\n### What is bytecode metadata?\n\nMetadata is data that describes and gives information about other data. [Bytecode (contract) metadata](https://solidity.readthedocs.io/en/latest/metadata.html)\nin Solidity is supported since version 0.4.7 and is automatically generated by the Solidity compiler in the form of a JSON file.\nThe metadata file contains information about the compiled contract, e.g. the used compiler version, the sources used,\nthe ABI and the NatSpec documentation. The metadata file also contains IPFS and SWARM hashes of the source code, which allows\nto retrieve them if they are available.\n\nMetadata files can also contain literal sources, which means that the actual code of the contract is present in the metadata\nfile's source section. Literal sources will be covered by the Sourcify verification [in future](https://github.com/ethereum/sourcify/issues/187), too.\n\n### What is NatSpec?\n\n[NatSpec](https://solidity.readthedocs.io/en/latest/natspec-format.html) is short for Ethereum Natural Language Specification\nFormat. Solidity contracts can use NatSpec comments to provide rich documentation for functions, return variables and more.\nThe comments are categorized into developer-focused and end-user-focused messages. The end-user-focused messages can be crucial\nto users since they describe what the contract interaction will do in plain language. It is highly recommended to fully\nannotate Solidity contracts using NatSpec for all public interfaces.\n\nNatSpec comments can be displayed to the user at the time of interaction, e.g. by being prompted in the wallet interface\nbefore signing a transaction, or later as a comment, e.g. in a list of past transactions.\n\n## Sourcify\n\n### What is Sourcify?\n\nSourcify is an initiative which aims to make interacting with smart contracts on the blockchain safer and more transparent\nfor users.\n\nTo achieve this goal, Sourcify supports several efforts to foster adoption of open-source source verification, metadata files\nand NatSpec comments.\n\nAt its core, Sourcify currently maintains\n\n- an [interface](https://sourcify.dev/) that helps developers to verify metadata and contract source code.\n- a [contract repository](https://repo.sourcify.dev/) of all verified contracts.\n- a [monitoring & verifier service](https://github.com/ethereum/sourcify) that checks for new contracts on Ethereum blockchains\n  (mainnet and testnets) and tries to verify them automatically.\n\nSourcify basically provides the base layer, which allows other tools to be built on top of it. Its main purpose is to keep metadata\nand source files available via IPFS and Swarm (preventing that the links in the bytecode turn into dead links).\n\nBesides the technical infrastructure, Sourcify is also a collective movement to bring transparency and awareness to the space.\nWe try to educate and build bridges between development tools, wallets, interfaces and other components which all play an\nimportant role in demystifying interaction with smart contracts for the end user and hence making blockchain interactions safer.\n\n### How does the Sourcify monitoring & verifier service work?\n\nThe monitoring and verifier component...\n\n- listens for new blocks on blockchains and fetches transactions from them.\n- checks to see if their metadata and source code is published on IPFS or Swarm.\n- recompiles the code.\n- checks that it is the same as the deployed code.\n- permanently stores the source code, ABI and other metadata on IPFS.\n\n### How is the Sourcify verifier different to verifying my contracts on EtherScan?\n\nBefore we dive into the differences: EtherScan is doing invaluable work for the ecosystem with their\n[contract verification](https://etherscan.io/verifyContract) service, which we are very grateful for!\n\nHowever, there are some minor problems with the current setup in the EtherScan verification: EtherScan often \"flattens\" the code\nwhich makes it impossible to verify the metadata. At this point, not even EtherScan could recompile the code to the last byte.\nYou'd have to trust whoever uploaded the source code that this is the original source code with the correct NatSpec comments and variable names.\n\nSourcify adds the option to make any contract independently verifiable. It also covers another important aspect:\nthe availability of the code. Should EtherScan ever go down, there's no way to access their verified contracts anymore.\nSourcify tries to solve this by making the storage of the source files and the processes around the verification more\ndecentralized, independent and hence more resilient.\n\n### How is source verification & commenting your code with NatSpec connected and why is it more powerful if you do both?\n\nIf you verified that the code you deployed is an exact match to what you open-sourced that is great!\nDevelopers now can verify themselves that your dapp is actually doing what it promised.\n\nHowever, it will still be hard for end-users to understand what they are doing when interacting with your code.\nOnly by translating what the contract interactions mean into NatSpec you can help them comprehend what's going on under the\nhood. To ensure that you don't comment code with inadequate comments to mislead the users, all of the comments and metadata\nalso get published and verified. Malicious actors could of course still use \"wrong\" NatSpec comments, however, Sourcify would\nguarantee that the comments match those used at compilation time. Other developers could now check the NatSpec comments\nin the open-source code and verify their accuracy.\n\n#### Source Verification & NatSpec go hand-in-hand for greater transparency in contract interactions!\n\nIt's simple:\n\n- Only verifying source code: üìùüîç + ü§î‚ùì= ‚ùå (code is transparent, but end user does not understand it = bad)\n- Only using NatSpec: ü§ìüí° + üìùüôà = ‚ùå (end user understands, but NatSpec could be lying since code isn't verified = bad)\n- Using source verification and NatSpec: üìùüîç + ü§ìüí° = ‚úÖ (code is transparent, end users can understand it = awesome!)\n\n### How decentralized is Sourcify?\n\n- Contract repo: The Sourcify contract repository is published both via [HTTPS](https://repo.sourcify.dev/) as well\n  as on [IPFS](https://gateway.ipfs.io/ipns/QmNmBr4tiXtwTrHKjyppUyAhW1FQZMJTdnUrksA9hapS4u).\n- [Interfaces](https://sourcify.dev/): If you are using the Sourcify UI then you are\n  verifying via our verification service backend. However, you could also run this service yourself. All code is available in the\n  [EF Sourcify repository](https://github.com/ethereum/sourcify) and the [Sourcify GitHub organization](https://github.com/sourcifyeth).\n  Additionally, the Sourcify CLI will soon be [published](https://github.com/ethereum/sourcify/pull/184).\n\n## The User Side: Improving Dapp UX with Sourcify?\n\n### What's wrong about the current UX when signing transactions?\n\nYou probably already stumbled over a transaction which had random hex string in the description. If you went ahead and\nsigned this transaction you blindly trusted the developer of the dapp to do what they promised.\n\nWouldn't it be great to have the option to verify what is happening and take an informed decision instead?\n\nSourcify aims to add that needed context to signing decisions by displaying whether the source code has been verified and what\nthe contract interaction actually means in layman's terms.\n\n### How can we improve the UX using Sourcify?\n\nDevelopers can help users take an informed decision by commenting their code using NatSpec. To verify that their NatSpec\ncomments are actually accurate, they should publish the source files to an open directory.\n\nIt's important that interface tools like wallets display the NatSpec comments to make them visible to the user before\nthe contract interaction.\n\n### How can I check whether a contract has been verified?\n\nCurrently, contracts that have been verified via Sourcify don't yet get a special label or tag on wallets or interfaces\n(like blockexplorers). It would be great it that were the case in future though!\n\nFor now, you can use the Sourcify contract repository. It can be accessed via [HTTPS](https://repo.sourcify.dev/)\nor [IPFS](https://gateway.ipfs.io/ipns/QmNmBr4tiXtwTrHKjyppUyAhW1FQZMJTdnUrksA9hapS4u).\n\nUse the contract's address and search for it in the repository. If it is there, it is a match (aka verified). üéâ\n\n### What are full matches?\n\nFull matches mean that the source files as well as the metadata files were an exact match between the deployed bytecode\nand the published files.\n\n### What are partial matches?\n\nPartial matches occur when the metadata hash does not match. This means that the source code compiles to the same bytecode\nand thus the contract behaves in the same way, but the source code can be different: Variables can have misleading names,\ncomments can be different and especially the NatSpec comments could have been modified.\n\n## The Tooling Side\n\n### What tooling is needed to make source verification more convenient?\n\nThe right support by existing and new tools can help make source verification much easier and more convenient for developers.\n\nQuick wins on the tooling side include:\n\n- Encourage auto-publishing of source files via deployment tools and make publishing the default option if license is\n  specified as open source (licence identifiers are supported as of [Solidity v0.6.8](https://github.com/ethereum/solidity/releases/tag/v0.6.8)).\n- Create libraries (in different languages) that wallets can use to easily recompile bytecode.\n\n### What is needed on the wallet / UI side to make users aware of verified contracts?\n\nWallets and user interfaces are a crucial puzzle piece to bring awareness and broader adoption to source verification and\nNatSpec comments. To make users aware of verified contracts, wallets and other user interfaces could:\n\n- Show which contracts are verified and which are not during contract interaction.\n- Warn users if a contract has not been verified.\n- Always display the NatSpec comments, if available.\n- Warn users if NatSpec comments have not been verified and educate about the fact, that those explanations could potentially lie.\n- Educate users to only sign an interaction which is not NatSpec-commented if they know what they are doing.\n","availableURLs":["/2023/05/10/solidity-0.8.20-release-announcement","/2023/03/10/solidity-developer-survey-2022-results","/2023/02/22/user-defined-operators","/2023/02/22/solidity-0.8.19-release-announcement","/2023/02/01/solidity-0.8.18-release-announcement","/2022/12/07/solidity-developer-survey-2022-announcement","/2022/12/05/solidity-core-team-updates","/2022/09/08/storage-write-removal-before-conditional-termination","/2022/09/08/solidity-0.8.17-release-announcement","/2022/08/08/solidity-0.8.16-release-announcement","/2022/08/08/calldata-tuple-reencoding-head-overflow-bug","/2022/06/15/solidity-0.8.15-release-announcement","/2022/06/15/inline-assembly-memory-side-effects-bug","/2022/06/15/dirty-bytes-array-to-storage-bug","/2022/05/17/solidity-0.8.14-release-announcement","/2022/05/17/data-location-inheritance-bug","/2022/05/17/calldata-reencode-size-check-bug","/2022/05/03/solidity-summit-2022-recap","/2022/04/08/announcing-the-underhanded-contest-winners-2022","/2022/03/16/solidity-0.8.13-release-announcement","/2022/03/16/encodecall-bug","/2022/02/22/solidity-summit-2022-announcement","/2022/02/16/solidity-0.8.12-release-announcement","/2022/02/09/underhanded-solidity-contest-2022-announcement","/2022/02/07/solidity-developer-survey-2021-results","/2021/12/20/solidity-0.8.11-release-announcement","/2021/11/18/solidity-developer-survey-2021","/2021/11/09/solidity-0.8.10-release-announcement","/2021/09/29/user-defined-value-types-bug","/2021/09/29/solidity-0.8.9-release-announcement","/2021/09/29/signed-immutables-bug","/2021/09/27/user-defined-value-types","/2021/09/27/solidity-0.8.8-release-announcement","/2021/08/11/solidity-0.8.7-release-announcement","/2021/06/22/solidity-0.8.6-release-announcement","/2021/06/10/solidity-0.8.5-release-announcement","/2021/05/03/soliditylangorg-umbrella-domain","/2021/04/21/solidity-0.8.4-release-announcement","/2021/04/21/decoding-from-memory-bug","/2021/04/21/custom-errors","/2021/04/01/announcing-solidity-collectibles","/2021/03/23/solidity-0.8.3-release-announcement","/2021/03/23/keccak-optimizer-bug","/2021/03/02/solidity-0.8.2-release-announcement","/2021/03/02/saving-gas-with-simple-inliner","/2021/02/15/contributing-to-solidity-101","/2021/02/10/an-introduction-to-soliditys-fuzz-testing-approach","/2021/02/01/launching-the-solidity-forum","/2021/01/27/solidity-0.8.1-release-announcement","/2021/01/26/solidity-developer-survey-2020-results","/2020/12/16/solidity-v0.8.0-release-announcement","/2020/12/16/solidity-0.7.6-release-announcement","/2020/12/09/solidity-developer-survey-2020","/2020/12/03/solidity-underhanded-contest-winners","/2020/11/18/solidity-0.7.5-release-announcement","/2020/11/04/solidity-ama-1-recap","/2020/10/28/solidity-0.8.x-preview","/2020/10/19/solidity-0.7.4-release-announcement","/2020/10/19/empty-byte-array-copy-bug","/2020/10/07/solidity-dynamic-array-cleanup-bug","/2020/10/07/solidity-0.7.3-release-announcement","/2020/09/28/solidity-0.7.2-release-announcement","/2020/09/21/solidity-underhanded-contest","/2020/09/18/meet-the-team","/2020/09/02/solidity-0.7.1-release-announcement","/2020/07/28/solidity-v0.7.0-release-announcement","/2020/07/22/Solidity-0612-release-announcement","/2020/07/08/solidity-turns-5","/2020/07/07/Solidity-0611-release-announcement","/2020/06/25/sourcify-faq","/2020/06/18/solidity-0.6-inheritance","/2020/06/11/Solidity-0610-release-announcement","/2020/06/09/solidity-summit-recap","/2020/06/05/Solidity-069-release-announcement","/2020/06/02/Sourcify-Towards-Safer-Contract-Interaction-for-Humans","/2020/05/26/array-slices","/2020/05/14/Solidity-068-release-announcement","/2020/05/13/immutable-keyword","/2020/05/04/solidity-0.6.7-release-announcement","/2020/04/17/Solidity-Summit-2020-Goes-Interspace","/2020/04/09/solidity-0.6.6-release-announcement","/2020/04/06/solidity-0.6.5-release-announcement","/2020/04/06/memory-creation-overflow-bug","/2020/03/23/fallback-receive-split","/2020/03/17/solidity-0.5.17-release-announcement","/2020/03/10/solidity-0.6.4-release-announcement","/2020/02/18/solidity-0.6.3-release-announcement","/2020/01/29/solidity-0.6-try-catch","/2020/01/27/solidity-0.6.2-release-announcement","/2020/01/02/solidity-0.6.1-release-announcement","/2020/01/02/solidity-0.5.16-release-announcement","/2019/12/17/solidity-0.6.0-release-announcement","/2019/12/17/solidity-0.5.15-release-announcement","/2019/12/09/solidity-0.5.14-release-announcement","/2019/11/14/solidity-0.5.13-release-announcement","/2019/10/01/solidity-0.5.12-release-announcement","/2019/08/12/solidity-0.5.11-release-announcement","/2019/06/25/solidity-storage-array-bugs","/2019/06/25/solidity-0.5.10-release-announcement","/2019/05/28/solidity-0.5.9-release-announcement","/2019/04/30/solidity-0.5.8-release-announcement","/2019/04/29/solidity-0.4.26-release-announcement","/2019/03/26/solidity-optimizer-and-abiencoderv2-bug","/2019/03/26/solidity-0.5.7-release-announcement","/2019/03/13/solidity-0.5.6-release-announcement","/2019/03/05/solidity-0.5.5-release-announcement","/2019/02/12/solidity-0.5.4-release-announcement","/2019/01/22/solidity-0.5.3-release-announcement","/2018/12/19/solidity-0.5.2-release-announcement","/2018/12/03/solidity-0.5.1-release-announcement","/2018/11/13/solidity-0.5.0-release-announcement","/2018/09/13/solidity-bugfix-release","/2018/09/13/solidity-0.4.25-release-announcement","/2018/05/16/solidity-0.4.24-release-announcement","/2018/04/19/solidity-0.4.23-release-announcement","/2018/04/17/solidity-0.4.22-release-announcement","/2018/03/08/solidity-0.4.21-release-announcement","/2018/02/14/solidity-0.4.20-release-announcement","/2017/11/30/solidity-0.4.19-release-announcement","/2017/10/18/solidity-0.4.18-release-announcement","/2017/09/21/solidity-0.4.17-release-announcement","/2017/08/24/solidity-0.4.16-release-announcement","/2017/08/08/solidity-0.4.15-release-announcement","/2017/07/31/solidity-0.4.14-release-announcement","/2017/07/06/solidity-0.4.13-release-announcement","/2017/07/03/solidity-0.4.12-release-announcement","/2017/05/03/solidity-optimizer-bug","/2017/05/03/solidity-0.4.11-release-announcement","/2017/03/15/solidity-0.4.10-release-announcement","/2017/01/31/solidity-0.4.9-release-announcement","/2017/01/13/solidity-0.4.8-release-announcement","/2016/12/15/solidity-0.4.7-release-announcement","/2016/11/22/solidity-0.4.6-release-announcement","/2016/11/21/solidity-0.4.5-release-announcement","/2016/11/09/analysis-storage-corruption-bug","/2016/11/01/solidity-0.4.4-release-announcement","/2016/11/01/security-alert-solidity-variables-can-overwritten-storage","/2016/10/25/solidity-0.4.3-release-announcement","/2016/09/17/solidity-0.4.2-release-announcement","/2016/09/09/solidity-0.4.1-release-announcement","/2016/09/08/solidity-0.4.0-release-announcement","/2016/09/01/formal-methods-roadmap","/2016/08/10/solidity-0.3.6-release-announcement","/2016/06/10/solidity-0.3.5-release-announcement","/2016/06/10/smart-contract-security","/2016/05/31/solidity-0.3.4-release-announcement","/2016/05/27/solidity-0.3.3-release-announcement","/2016/04/18/solidity-0.3.2-release-announcement","/2016/03/31/solidity-0.3.1-release-announcement","/2016/03/11/solidity-0.3.0-release-announcement","/2016/02/17/solidity-0.2.2-release-announcement","/2016/01/30/solidity-0.2.1-release-announcement","/2015/12/01/solidity-0.2.0-release-announcement","/2015/11/17/solidity-0.1.7-release-announcement","/2015/10/16/solidity-0.1.6-release-announcement","/2015/10/07/solidity-0.1.5-release-announcement","/2015/09/30/solidity-0.1.4-release-announcement","/2015/09/22/solidity-0.1.3-release-announcement","/2015/08/21/solidity-0.1.2-release-announcement"]},"__N_SSG":true}