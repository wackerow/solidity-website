{"pageProps":{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.8.0 Release Announcement","date":"2020-12-16","author":"Solidity Team","category":"Releases"},"content":"\n[Solidity 0.8.0](https://github.com/ethereum/solidity/releases/tag/v0.8.0) is a breaking release of the Solidity compiler and language.\n\nSome of the new features of this release have been elaborated in the [0.8.x preview release post](https://blog.soliditylang.org/2020/10/28/solidity-0.8.x-preview/). Please consider the preview release binary superseded and do not use it anymore.\n\n## Notable New Features and Changes\n\nAs per ususal, this breaking release does not include many features but rather changes that require a\nbackwards-incompatible adjustment in syntax or semantics. For a detailed explanation,\nplease see the [documentation](https://docs.soliditylang.org/en/latest/080-breaking-changes.html).\n\nThe change that will affect most users is that arithmetic operations are now checked by default,\nwhich means that overflow and underflow will cause a revert. This feature can be disabled locally by using an `unchecked` block.\n\nThe second change that is very visible is that the ABI coder v2 is activated by default. You can\nactivate the old coder using `pragma abicoder v1`, or explicitly select v2\nusing `pragma abicoder v2` - which has the same effect as `pragma experimental ABIEncoderV2` had.\nABI coder v2 is more complex than v1 but also performs additional checks on the input and supports\na larger set of types than v1.\n\nFurthermore, internal errors like division by zero, assertion failure and others\ndo not use the invalid opcode anymore, but use `revert` with a special error message,\nin order to not waste gas in such situations.\n\nAnother important change is that we restricted the possibilities of explicit conversions\nto avoid ambiguities. All conversions that were possible before are still possible, but\nyou might have to perform two conversions to get there - which does not affect the generated code, though.\n\nThese are only some of the important breaking changes in 0.8.0, please refer to the changelog below for the full list!\n\n### Checked Arithmetic\n\nThe \"Checked Arithmetic\" feature of Solidity 0.8.x consists of three sub-features:\n\n- Revert on assertion failures and similar conditions instead of using the invalid opcode.\n- Checked arithmetic, i.e., revert on overflows, underflows etc.\n- `unchecked` blocks.\n\n#### Revert on assertion failures and similar conditions instead of using the invalid opcode\n\nPreviously, internal errors like division by zero, failing assertions, array access out of bounds,\netc., would result in an invalid opcode being executed. The idea was to distinguish\nthese more critical errors from non-critical errors that lie outside of the domain\nof the Smart Contract programmer like invalid input, not enough balance for a token transfer,\nand so on. These non-critical errors use the `revert` opcode and optionally add an error description.\n\nThe problem with the invalid opcode is that, in contrast to the `revert` opcode, it consumes all gas available.\nThis makes it very expensive and you should try to avoid it at all cost.\n\nWe wanted to consider arithmetic overflow as a critical error, but did not want to cause it to consume all gas.\nAs a middle ground, we chose to use the `revert` opcode, but provide different error data\nso that static (and dynamic) analysis tools can easily distinguish them.\n\nMore specifically:\n\n- Non-critical errors will revert either with empty error data or with error data that\n  corresponds to the ABI-encoding of a function call to a function with the signature `Error(string)`.\n- Critical errors revert with error data that corresponds to the ABI-encoding of a function call\n  to a function with the signature `Panic(uint256)`.\n\nBecause of that, we also use the term \"panic\" for such critical errors.\n\nTo distinguish the two situations, you can take a look at the first four bytes of the return data in case\nof a failure. If it is `0x4e487b71`, then it is a panic, if it is `0x08c379a0`\nor if the message is empty, it is a \"regular\" error.\n\nPanics use specific error codes to distinguish certain situations in which the panic is triggered.\nThis is the current list of error codes:\n\n1. 0x01: If you call `assert` with an argument that evaluates to false.\n2. 0x11: If an arithmetic operation results in underflow or overflow outside of an `unchecked { ... }` block.\n3. 0x12: If you divide or divide modulo by zero (e.g. `5 / 0` or `23 % 0`).\n4. 0x21: If you convert a value that is too big or negative into an enum type.\n5. 0x22: If you access a storage byte array that is incorrectly encoded.\n6. 0x31: If you call `.pop()` on an empty array.\n7. 0x32: If you access an array, `bytesN` or an array slice at an out-of-bounds or negative index (i.e. `x[i]` where `i >= x.length` or `i < 0`).\n8. 0x41: If you allocate too much memory or create an array that is too large.\n9. 0x51: If you call a zero-initialized variable of internal function type.\n\nThis list of codes can be extended in the future.\n\nNote that you currently cannot use `try ... catch Panic(uint _code) { ... }` to catch a panic,\nbut this is planned for the near future.\n\n#### Checked arithmetic, i.e., revert on overflows, underflows etc.\n\nBy default, all arithmetic operations will perform overflow and underflow checks\n(Solidity already had division by zero checks). In case of an underflow or\noverflow, a `Panic(0x11)` error will be thrown and the call will revert.\n\nThe following code, for example, will trigger such an error:\n\n```solidity\ncontract C {\n    function f() public pure {\n        uint x = 0;\n        x--;\n    }\n}\n```\n\nThe checks are based on the actual type of the variable, so even if the result would fit\nan EVM word of 256 bits, if your type is `uint8` and if the result is larger than `255`,\nit will trigger a `Panic`.\n\nWe did not introduce checks for explicit type conversions from larger to smaller\ntypes, because we think that such checks might be unexpected. We would love to get\nyour input on that matter!\n\nThe following operations (including their compound assignment versions like `+=`) now have checks that they did not have before:\n\n- addition (`+`), subtraction (`-`), multiplication (`*`)\n- increment and decrement (`++` / `--`)\n- unary negation (`-`)\n- exponentiation (`**`)\n- division (see below) (`/`)\n\nThere are some edge cases you might not expect.\nFor example, unary negation can trigger a panic on signed types.\nThe problem is that in two's complement representation, there is one more negative number for each bit width\nthan there are positive numbers. This means that the following code will trigger a panic:\n\n```solidity\nfunction f() pure {\n    int8 x = -128;\n    -x;\n}\n```\n\nThe reason is that `128` does not fit an 8-bit signed integer.\n\nFor the same reason, signed division can result in a panic:\n\n```solidity\nfunction f() pure {\n    int8 x = -128;\n    x/(-1);\n}\n```\n\nEveryone who wanted to write a `SafeMath` function for exponentiation probably noticed\nthat it is rather expensive to do that because the EVM does not provide overflow signalling.\nEssentially you have to implement your own `exp` routine without using the `exp` opcode\nfor the general case.\n\nWe hope that we found a rather efficient implementation and would also appreciate your feedback about that!\n\nFor many special cases, we actually implemented it using the `exp` opcode instead of our own implementation.\nMore specifically, exponentiation operations that use a literal number as base will use the `exp` opcode directly.\nThere are also specialized code paths for bases that are variables with small value. For bases up to 306,\nif the exponent is smaller than a hard-coded safe upper bound, it will use the `exp` opcode directly.\nIf the base or the exponent is too large, it might fall back to the loop-based implementation.\n\n#### `unchecked` Blocks\n\nSince checked arithmetic uses more gas, as discussed in the previous section, and\nbecause there are times when you really want the wrapping behaviour, for example when\nimplementing cryptographic routines, we provide a way to disable the checked arithmetic and\nre-enable the previous \"wrapping\" or \"modulo\" arithmetic:\n\nAll operations inside a block of the form `unchecked { ... }` use wrapping arithmetic. You can use\nthis special block as a regular statement inside another block:\n\n```solidity\ncontract C {\n    function f() public pure returns (uint) {\n        uint x = 0;\n        unchecked { x--; }\n        return x;\n    }\n}\n```\n\nAn unchecked block can contain any number or any kind of statement\nand will create its own variable scope.\nIf there is a function call inside the unchecked block, the function will\nnot inherit the setting - you have to use another `unchecked` block inside the function\nif you also want it to use wrapping arithmetic.\n\nWe decided for some restrictions for the `unchecked` block:\n\n1. In modifiers you cannot use `_;` inside an `unchecked` block, because this might lead to confusion about whether the property is inherited.\n\n2. You can only use it inside a block but not as a replacement for a block. The following code snippets, for example, are both invalid:\n\n   ```solidity\n   function f() unchecked { uint x = 7; }\n   ```\n\n   ```solidity\n   function f() pure {\n       uint x;\n       for (uint i = 0; i < 100; i++) unchecked { x += i; }\n   }\n   ```\n\n   You have to wrap the unchecked blocks in another block to make it work.\n\n### Explicit Conversions\n\nExplicit conversions are only possible when there\nis at most one change in sign, width, payability or type-category (`int`, `address`, `bytesNN`, etc.).\n\nFor example, converting `int8` to `uint16` is only possible, if you go through `uint8` or `int16`.\nSince the choice of the intermediate conversion will have an effect on the result\nwe wanted to make it explicit:\n\n- `uint16(int16(int8(-1)))` results in `0xffff`, while\n- `uint16(uint8(int8(-1)))` is `0xff`.\n\nThere are more such changes in relation to payable addresses, literals, enums and contracts. For the full list\nof changes, please see the [documentation](https://docs.soliditylang.org/en/latest/080-breaking-changes.html).\n\n## General Remarks\n\nSince we usually do not backport bugfixes, it is recommended to upgrade all code to be compatible with Solidity v0.8.0.\n\nYou can find a guide on how to update your code [here](https://docs.soliditylang.org/en/latest/080-breaking-changes.html#how-to-update-your-code).\n\nNote that changes listed below are the **changes between 0.7.6 and 0.8.0**. For changes introduced\nduring the 0.7.x series, please see the individual changelogs or release announcements on this blog.\n\n## Full Changelog\n\n### Breaking Changes:\n\n- Code Generator: All arithmetic is checked by default. These checks can be disabled using `unchecked { ... }`.\n- Code Generator: Cause a panic if a byte array in storage is accessed whose length is encoded incorrectly.\n- Code Generator: Use `revert` with error signature `Panic(uint256)` and error codes instead of invalid opcode on failing assertions.\n- Command Line Interface: JSON fields `abi`, `devdoc`, `userdoc` and `storage-layout` are now sub-objects rather than strings.\n- Command Line Interface: Remove the `--old-reporter` option.\n- Command Line Interface: Remove the legacy `--ast-json` option. Only the `--ast-compact-json` option is supported now.\n- General: Enable ABI coder v2 by default.\n- General: Remove global functions `log0`, `log1`, `log2`, `log3` and `log4`.\n- Parser: Exponentiation is right associative. `a**b**c` is parsed as `a**(b**c)`.\n- Scanner: Remove support for the `\\b`, `\\f`, and `\\v` escape sequences.\n- Standard JSON: Remove the `legacyAST` option.\n- Type Checker: Function call options can only be given once.\n- Type System: Declarations with the name `this`, `super` and `_` are disallowed, with the exception of public functions and events.\n- Type System: Disallow `msg.data` in `receive()` function.\n- Type System: Disallow `type(super)`.\n- Type System: Disallow enums with more than 256 members.\n- Type System: Disallow explicit conversions from negative literals and literals larger than `type(uint160).max` to `address` type.\n- Type System: Disallow the `byte` type. It was an alias to `bytes1`.\n- Type System: Explicit conversion to `address` type always returns a non-payable `address` type. In particular, `address(u)`, `address(b)`, `address(c)` and `address(this)` have the type `address` instead of `address payable` (Here `u`, `b`, and `c` are arbitrary variables of type `uint160`, `bytes20` and contract type respectively.)\n- Type System: Explicit conversions between two types are disallowed if it changes more than one of sign, width or kind at the same time.\n- Type System: Explicit conversions from literals to enums are only allowed if the value fits in the enum.\n- Type System: Explicit conversions from literals to integer type is as strict as implicit conversions.\n- Type System: Introduce `address(...).code` to retrieve the code as `bytes memory`. The size can be obtained via `address(...).code.length`, but it will currently always include copying the code.\n- Type System: Introduce `block.chainid` for retrieving the current chain id.\n- Type System: Support `address(...).codehash` to retrieve the codehash of an account.\n- Type System: The global variables `tx.origin` and `msg.sender` have type `address` instead of `address payable`.\n- Type System: Unary negation can only be used on signed integers, not on unsigned integers.\n- View Pure Checker: Mark `chainid` as view.\n- Yul: Disallow the use of reserved identifiers, such as EVM instructions, even if they are not available in the given dialect / EVM version.\n- Yul: The `assignimmutable` builtin in the \"EVM with objects\" dialect takes the base offset of the code to modify as an additional argument.\n\n### Language Features:\n\n- Super constructors can now be called using the member notation e.g. `M.C(123)`.\n\n### Bugfixes:\n\n- Type Checker: Perform proper truncating integer arithmetic when using constants in array length expressions.\n\n### AST Changes:\n\n- New AST Node `IdentifierPath` replacing in many places the `UserDefinedTypeName`.\n- New AST Node `UncheckedBlock` used for `unchecked { ... }`.\n\nA big thank you to all contributors who helped make this release possible!\n\nDownload the new version of Solidity [here](https://github.com/ethereum/solidity/releases/tag/v0.8.0).\n","availableURLs":["/2023/05/10/solidity-0.8.20-release-announcement","/2023/03/10/solidity-developer-survey-2022-results","/2023/02/22/user-defined-operators","/2023/02/22/solidity-0.8.19-release-announcement","/2023/02/01/solidity-0.8.18-release-announcement","/2022/12/07/solidity-developer-survey-2022-announcement","/2022/12/05/solidity-core-team-updates","/2022/09/08/storage-write-removal-before-conditional-termination","/2022/09/08/solidity-0.8.17-release-announcement","/2022/08/08/solidity-0.8.16-release-announcement","/2022/08/08/calldata-tuple-reencoding-head-overflow-bug","/2022/06/15/solidity-0.8.15-release-announcement","/2022/06/15/inline-assembly-memory-side-effects-bug","/2022/06/15/dirty-bytes-array-to-storage-bug","/2022/05/17/solidity-0.8.14-release-announcement","/2022/05/17/data-location-inheritance-bug","/2022/05/17/calldata-reencode-size-check-bug","/2022/05/03/solidity-summit-2022-recap","/2022/04/08/announcing-the-underhanded-contest-winners-2022","/2022/03/16/solidity-0.8.13-release-announcement","/2022/03/16/encodecall-bug","/2022/02/22/solidity-summit-2022-announcement","/2022/02/16/solidity-0.8.12-release-announcement","/2022/02/09/underhanded-solidity-contest-2022-announcement","/2022/02/07/solidity-developer-survey-2021-results","/2021/12/20/solidity-0.8.11-release-announcement","/2021/11/18/solidity-developer-survey-2021","/2021/11/09/solidity-0.8.10-release-announcement","/2021/09/29/user-defined-value-types-bug","/2021/09/29/solidity-0.8.9-release-announcement","/2021/09/29/signed-immutables-bug","/2021/09/27/user-defined-value-types","/2021/09/27/solidity-0.8.8-release-announcement","/2021/08/11/solidity-0.8.7-release-announcement","/2021/06/22/solidity-0.8.6-release-announcement","/2021/06/10/solidity-0.8.5-release-announcement","/2021/05/03/soliditylangorg-umbrella-domain","/2021/04/21/solidity-0.8.4-release-announcement","/2021/04/21/decoding-from-memory-bug","/2021/04/21/custom-errors","/2021/04/01/announcing-solidity-collectibles","/2021/03/23/solidity-0.8.3-release-announcement","/2021/03/23/keccak-optimizer-bug","/2021/03/02/solidity-0.8.2-release-announcement","/2021/03/02/saving-gas-with-simple-inliner","/2021/02/15/contributing-to-solidity-101","/2021/02/10/an-introduction-to-soliditys-fuzz-testing-approach","/2021/02/01/launching-the-solidity-forum","/2021/01/27/solidity-0.8.1-release-announcement","/2021/01/26/solidity-developer-survey-2020-results","/2020/12/16/solidity-v0.8.0-release-announcement","/2020/12/16/solidity-0.7.6-release-announcement","/2020/12/09/solidity-developer-survey-2020","/2020/12/03/solidity-underhanded-contest-winners","/2020/11/18/solidity-0.7.5-release-announcement","/2020/11/04/solidity-ama-1-recap","/2020/10/28/solidity-0.8.x-preview","/2020/10/19/solidity-0.7.4-release-announcement","/2020/10/19/empty-byte-array-copy-bug","/2020/10/07/solidity-dynamic-array-cleanup-bug","/2020/10/07/solidity-0.7.3-release-announcement","/2020/09/28/solidity-0.7.2-release-announcement","/2020/09/21/solidity-underhanded-contest","/2020/09/18/meet-the-team","/2020/09/02/solidity-0.7.1-release-announcement","/2020/07/28/solidity-v0.7.0-release-announcement","/2020/07/22/Solidity-0612-release-announcement","/2020/07/08/solidity-turns-5","/2020/07/07/Solidity-0611-release-announcement","/2020/06/25/sourcify-faq","/2020/06/18/solidity-0.6-inheritance","/2020/06/11/Solidity-0610-release-announcement","/2020/06/09/solidity-summit-recap","/2020/06/05/Solidity-069-release-announcement","/2020/06/02/Sourcify-Towards-Safer-Contract-Interaction-for-Humans","/2020/05/26/array-slices","/2020/05/14/Solidity-068-release-announcement","/2020/05/13/immutable-keyword","/2020/05/04/solidity-0.6.7-release-announcement","/2020/04/17/Solidity-Summit-2020-Goes-Interspace","/2020/04/09/solidity-0.6.6-release-announcement","/2020/04/06/solidity-0.6.5-release-announcement","/2020/04/06/memory-creation-overflow-bug","/2020/03/23/fallback-receive-split","/2020/03/17/solidity-0.5.17-release-announcement","/2020/03/10/solidity-0.6.4-release-announcement","/2020/02/18/solidity-0.6.3-release-announcement","/2020/01/29/solidity-0.6-try-catch","/2020/01/27/solidity-0.6.2-release-announcement","/2020/01/02/solidity-0.6.1-release-announcement","/2020/01/02/solidity-0.5.16-release-announcement","/2019/12/17/solidity-0.6.0-release-announcement","/2019/12/17/solidity-0.5.15-release-announcement","/2019/12/09/solidity-0.5.14-release-announcement","/2019/11/14/solidity-0.5.13-release-announcement","/2019/10/01/solidity-0.5.12-release-announcement","/2019/08/12/solidity-0.5.11-release-announcement","/2019/06/25/solidity-storage-array-bugs","/2019/06/25/solidity-0.5.10-release-announcement","/2019/05/28/solidity-0.5.9-release-announcement","/2019/04/30/solidity-0.5.8-release-announcement","/2019/04/29/solidity-0.4.26-release-announcement","/2019/03/26/solidity-optimizer-and-abiencoderv2-bug","/2019/03/26/solidity-0.5.7-release-announcement","/2019/03/13/solidity-0.5.6-release-announcement","/2019/03/05/solidity-0.5.5-release-announcement","/2019/02/12/solidity-0.5.4-release-announcement","/2019/01/22/solidity-0.5.3-release-announcement","/2018/12/19/solidity-0.5.2-release-announcement","/2018/12/03/solidity-0.5.1-release-announcement","/2018/11/13/solidity-0.5.0-release-announcement","/2018/09/13/solidity-bugfix-release","/2018/09/13/solidity-0.4.25-release-announcement","/2018/05/16/solidity-0.4.24-release-announcement","/2018/04/19/solidity-0.4.23-release-announcement","/2018/04/17/solidity-0.4.22-release-announcement","/2018/03/08/solidity-0.4.21-release-announcement","/2018/02/14/solidity-0.4.20-release-announcement","/2017/11/30/solidity-0.4.19-release-announcement","/2017/10/18/solidity-0.4.18-release-announcement","/2017/09/21/solidity-0.4.17-release-announcement","/2017/08/24/solidity-0.4.16-release-announcement","/2017/08/08/solidity-0.4.15-release-announcement","/2017/07/31/solidity-0.4.14-release-announcement","/2017/07/06/solidity-0.4.13-release-announcement","/2017/07/03/solidity-0.4.12-release-announcement","/2017/05/03/solidity-optimizer-bug","/2017/05/03/solidity-0.4.11-release-announcement","/2017/03/15/solidity-0.4.10-release-announcement","/2017/01/31/solidity-0.4.9-release-announcement","/2017/01/13/solidity-0.4.8-release-announcement","/2016/12/15/solidity-0.4.7-release-announcement","/2016/11/22/solidity-0.4.6-release-announcement","/2016/11/21/solidity-0.4.5-release-announcement","/2016/11/09/analysis-storage-corruption-bug","/2016/11/01/solidity-0.4.4-release-announcement","/2016/11/01/security-alert-solidity-variables-can-overwritten-storage","/2016/10/25/solidity-0.4.3-release-announcement","/2016/09/17/solidity-0.4.2-release-announcement","/2016/09/09/solidity-0.4.1-release-announcement","/2016/09/08/solidity-0.4.0-release-announcement","/2016/09/01/formal-methods-roadmap","/2016/08/10/solidity-0.3.6-release-announcement","/2016/06/10/solidity-0.3.5-release-announcement","/2016/06/10/smart-contract-security","/2016/05/31/solidity-0.3.4-release-announcement","/2016/05/27/solidity-0.3.3-release-announcement","/2016/04/18/solidity-0.3.2-release-announcement","/2016/03/31/solidity-0.3.1-release-announcement","/2016/03/11/solidity-0.3.0-release-announcement","/2016/02/17/solidity-0.2.2-release-announcement","/2016/01/30/solidity-0.2.1-release-announcement","/2015/12/01/solidity-0.2.0-release-announcement","/2015/11/17/solidity-0.1.7-release-announcement","/2015/10/16/solidity-0.1.6-release-announcement","/2015/10/07/solidity-0.1.5-release-announcement","/2015/09/30/solidity-0.1.4-release-announcement","/2015/09/22/solidity-0.1.3-release-announcement","/2015/08/21/solidity-0.1.2-release-announcement"]},"__N_SSG":true}