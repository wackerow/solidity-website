{"pageProps":{"frontmatter":{"layout":"post","published":true,"title":"Feature Deep-Dive: User-Defined Operators","date":"2023-02-22","author":"Kamil Śliwak, Matheus Aguiar","category":"Explainers"},"content":"\nThe highlight of [Solidity 0.8.19](https://github.com/ethereum/solidity/releases/tag/v0.8.19) release\nis the support for defining _operators_ on [user-defined value types](https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types) (UDVTs).\n\nIf you have not been keeping up with recent features, UDVTs are a new class of types introduced in Solidity 0.8.8.\nThey provide an abstraction over an elementary value type that results in a completely new type.\nThis is similar to creating an alias, but the new type is distinct from the underlying value type\nand all other UDVTs derived from that underlying type.\nThe ability to use operators is meant to bring the UDVTs closer to being as natural to use as the\nbuilt-in types and promote the use of type-safe interfaces.\nBelow, we are going to take a closer look into the details of this new mechanism.\n\n### A Quick Refresher\n\nBefore we get into the details of the new feature and how it affects the language, it may be a good\nidea to first go over the two existing features that it builds upon: built-in operators and `using for`.\n\n#### Built-in Operators\n\nSolidity, like the vast majority of programming languages,\n[offers a set of operators](https://docs.soliditylang.org/en/latest/types.html#operators) as syntactic sugar\nover common arithmetical and logical functions.\nThe difference between operators and functions is purely syntactical, and the decision\nto choose one over the other is to a large extent a matter of readability.\nThe use of operators makes expressions more concise, which is helpful as long as they are well\nunderstood by the reader.\nWhat is included in that set varies widely from language to language.\n\nHere is the full list for Solidity:\n\n| Category             | Operators                                                           |\n| -------------------- | ------------------------------------------------------------------- |\n| Bitwise              | `&`, `\\|`, `^`, `<<`, `>>`, `~`                                     |\n| Arithmetic           | `+`, `-`, `*`, `/`, `%`, `**`                                       |\n| Comparison           | `==`, `!=`, `<`, `<=`, `>`, `>=`                                    |\n| Boolean              | `!`, `&&`, `\\|\\|`                                                   |\n| Increment/decrement  | `++`, `--`                                                          |\n| Simple assignment    | `=`                                                                 |\n| Composite assignment | `+=`, `-=`, `^=`, `*=`, `/=`, `%=`, `&=`, `\\|=`, `^=`, `<<=`, `>>=` |\n| Miscellaneous        | `delete`, `new`, `.`, `()`, `[]`, `?:`                              |\n\nIt is important to note that in many languages, an assignment is a statement that is handled in a special way.\nIn Solidity, like in the C-like languages it took inspiration from, an assignment operator can be freely used in\nexpressions on par with other operators.\n\nIn most cases, built-in operators are only defined for [value types](https://docs.soliditylang.org/en/latest/types.html#value-types).\nNotable exceptions are the simple assignment and the \"miscellaneous\" group.\nFor example, you can put almost anything in parentheses or branches of the ternary operator, as a part\nof a bigger expression, even if its type cannot be named or even assigned to anything.\n\n#### `using for`\n\nSince operators are a purely syntactic element, you can always use a function as a substitute.\nSolidity has a mechanism that is often used this way:\n[`using for`](https://docs.soliditylang.org/en/latest/contracts.html#using-for).\n\nThe directive `using ... for ...` can be used to attach functions to a type.\nThese functions can then be used as members on any object of that type and receive the object as\ntheir first parameter.\n\n```solidity\npragma solidity ^0.8.13;\n\ntype Int is int;\nusing {add} for Int global;\n\nfunction add(Int a, Int b) pure returns (Int) {\n    return Int.wrap(Int.unwrap(a) + Int.unwrap(b));\n}\n\nfunction test(Int a, Int b) pure returns (Int) {\n    return a.add(b);\n}\n```\n\nCurrently, `using for` has 3 forms:\n\n1. `using L for T`: attaches all non-private functions from library `L` to type `T`.\n1. `using L for *`: attaches all non-private functions from library `L` to any type, including types that\n   cannot be named in the language and used explicitly (e.g. types of literals or array slices).\n1. `using {f, L.g, ...} for T`: attaches given free or library functions `f`, `L.g`, ... to type `T`.\n\nThe directive can be used:\n\n- ✅ At file level.\n- ✅ Inside contract and library definitions.\n\nThe directive can not be used:\n\n- ❌ Inside interface definitions.\n\nWhen used inside contracts, it is not inherited.\nIts effects extend only to the contract that has it and not to any other contracts derived from it.\n\nAt file level, the directive affects all the free functions, contracts and libraries defined within that file.\nIt does not affect other files that import the file containing it, unless it is marked as `global`.\n`global` extends its effect to all files.\nThe use of `global` is possible only with UDVTs, structs, and enums that are defined in its source unit.\n\n### Introducing User-Defined Operators\n\nThe new feature extends the third form of the `using for` syntax to allow binding operators to functions.\nThe function is invoked whenever the operator is used on the values of the type:\n\n```solidity\npragma solidity ^0.8.19;\n\ntype Int is int;\nusing {add as +} for Int global;\n\nfunction add(Int a, Int b) pure returns (Int) {\n    return Int.wrap(Int.unwrap(a) + Int.unwrap(b));\n}\n\nfunction test(Int a, Int b) pure returns (Int) {\n    return a + b; // Equivalent to add(a, b)\n}\n```\n\nAn operator can only be bound in a `global` directive and its definition must be a `pure` free function.\nThe type specified in `using for` must be a user-defined value type and must be the type\nof all the parameters of the function and its return value.\nThe only exception are comparison operator definitions, where the return type must be `bool`.\n\nSince currently there are no implicit conversions allowed to and from UDVTs, user-defined operators\nmust always be invoked with exact types.\n\nThe following operators can be defined:\n\n| Category   | Operators                        |\n| ---------- | -------------------------------- |\n| Bitwise    | `&`, `\\|`, `^`, `~`              |\n| Arithmetic | `+`, `-`, `*`, `/`, `%`          |\n| Comparison | `==`, `!=`, `<`, `<=`, `>`, `>=` |\n\nOf the operators listed above, `~` is unary, `-` can be both unary and binary and the rest is always binary.\nNote that Solidity does not have a unary `+`.\nUnary and binary `-` are considered different operators and need separate definitions.\nWhether `-` refers to the unary or binary variant depends on the number of parameters of the function.\n\nIt is not possible to replace operator definitions.\nThis applies both to the built-in operator definitions provided by the compiler and to operators\nbound to a function provided by the user.\nOnce the operator is bound, the definition cannot be changed.\n\n#### Operator Bindings vs Attached Functions\n\nUser-defined operators are independent of attached functions.\nOne can be done without the other, and both can be done simultaneously, even in the same `using for` directive.\n\nThe following example illustrates this:\n\n```solidity\npragma solidity ^0.8.19;\n\ntype Int is int;\nusing {add as +} for Int global;\nusing {sub as -, sub} for Int global;\n\nfunction add(Int a, Int b) pure returns (Int) {\n    return Int.wrap(Int.unwrap(a) + Int.unwrap(b));\n}\n\nfunction sub(Int a, Int b) pure returns (Int) {\n    return Int.wrap(Int.unwrap(a) - Int.unwrap(b));\n}\n\nfunction test(Int x, Int y) pure {\n    x + y;\n    x.add(y); // ERROR: Member \"add\" not found or not visible after argument-dependent lookup in Int.\n\n    x - y;\n    x.sub(y); // OK -- \"sub\" was also attached in \"using for\"\n}\n```\n\nIn the above example, the function `add()` is used _only_ as the operator `+`, and not callable as `x.add(y)`\n(but it can, of course, be also called as `add(x, y)`).\n`sub()`, on the other hand, can both be used as the operator `-` and called on the type.\n\nThe rules for `using for global` with operators are the same as for attached functions\n(with an additional restriction that operators _must_ be global), i.e.\nit is only allowed at file level, the type must be defined in the same file and it makes\nthe operator available everywhere.\nNote that only the directive itself must be colocated with the type.\nThe operator definitions may be imported from a separate file.\n\n#### Parameter Cleanup\n\nIf you decide to use inline assembly in your operator implementation, you should be aware of\na dangerous pitfall when using types that do not fill the whole stack slot.\nAccessing Solidity variables in inline assembly bypasses the\n[variable cleanup](https://docs.soliditylang.org/en/latest/internals/variable_cleanup.html)\nmechanism that normally masks the dirty bits of your value.\nIn inline assembly you must perform that cleanup manually.\n\nConsider an example that naively accesses the parameters and return values of operators\nwithout properly cleaning up `uint8` values:\n\n```solidity\npragma solidity ^0.8.19;\n\ntype U8 is uint8;\nusing {yoloAdd as +, yoloDiv as /} for U8 global;\n\nfunction yoloAdd(U8 x, U8 y) pure returns (U8 z) {\n    assembly {\n        z := add(x, y) // Wrong! No cleanup.\n    }\n}\n\nfunction yoloDiv(U8 x, U8 y) pure returns (U8 z) {\n    assembly {\n        z := div(x, y) // Wrong! No cleanup.\n    }\n}\n\ncontract C {\n    function divAddNoOverflow(U8 a, U8 b, U8 c) external pure returns (U8) {\n        return a / (b + c);\n    }\n}\n```\n\nNow, let's see what happens when you call `divAddNoOverflow(4, 0xff, 3)`.\nYou might expect it to return 4, i.e. `8 / ((255 + 3) % 256)`.\nAfter all, `z` is based on `uint8` and an unchecked addition of 3 to 255 should wrap around and give you 2.\n`8 / 2` is 4.\nThis is not what happens.\nThe actual result is zero.\n\nNote that local variables take up whole stack slots and all calculations in inline assembly are\nperformed on 256-bit numbers.\nThe result of `add(0xff, 3)` is actually `0x0102` and `yoloAdd()` does not clear the higher bits.\n`yoloDiv()` then receives that value as `y`, and again does not clear the higher bits.\nThis results in an integer division by 258 rather than by 2.\n\nThe problem can be avoided with manual cleanup.\nThe code would work as designed if `add(x, y)` was replaced with\n\n```solidity\nand(0xff, add(and(0xff, x), and(0xff, y)))\n```\n\nand `div(x, y)` with\n\n```solidity\nand(0xff, div(and(0xff, x), and(0xff, y)))\n```\n\n#### Examples\n\n##### Unchecked Counter\n\nThis example shows how operators can be used to bypass the checked arithmetic for types\nspecifically defined for cases where those checks are superfluous:\n\n```solidity\npragma solidity ^0.8.19;\n\ntype UncheckedCounter is uint;\n\nusing {add as +, lt as <} for UncheckedCounter global;\n\nUncheckedCounter constant ONE = UncheckedCounter.wrap(1);\n\nfunction add(UncheckedCounter x, UncheckedCounter y) pure returns (UncheckedCounter) {\n    unchecked {\n        return UncheckedCounter.wrap(\n            UncheckedCounter.unwrap(x) +\n            UncheckedCounter.unwrap(y)\n        );\n    }\n}\n\nfunction lt(UncheckedCounter x, UncheckedCounter y) pure returns (bool) {\n    return UncheckedCounter.unwrap(x) < UncheckedCounter.unwrap(y);\n}\n\ncontract C {\n    uint internalCounter = 12;\n\n    function testCounter() public returns (uint) {\n        for (\n            UncheckedCounter i = UncheckedCounter.wrap(12);\n            i < UncheckedCounter.wrap(20);\n            i = i + ONE\n        )\n            ++internalCounter;\n\n        return internalCounter;\n    }\n}\n```\n\n##### A More Complex Abstract Example\n\nThis is a more complex example that shows multiple aspects of user-defined operators.\nThe exact calculations it performs do not matter, the point is to show the syntax in a larger context.\n\n`redBlueScore.sol`\n\n```solidity\npragma solidity ^0.8.19;\n\nimport {Red, Blue, Score, RED_LIMIT, BLUE_LIMIT} from \"./types.sol\";\n\ncontract RedBlueScore {\n    Red public redGauge;\n    Blue public blueGauge;\n\n    function voteRed(Red value, Red base) public {\n        require(-RED_LIMIT <= value * base && value * base <= RED_LIMIT);\n        redGauge = redGauge + value * base.exp(3);\n    }\n\n    function voteBlue(Blue value) public {\n        require(-BLUE_LIMIT <= value && value <= BLUE_LIMIT);\n        blueGauge = blueGauge + value - Blue.wrap(100);\n    }\n\n    function calculateScore() public view returns (Score) {\n        return\n            redGauge.toScore() / RED_LIMIT.toScore() -\n            blueGauge.toScore() / BLUE_LIMIT.toScore();\n    }\n}\n```\n\n`types.sol`\n\n```solidity\npragma solidity ^0.8.19;\n\nimport \"./operators.sol\" as op;\n\ntype Red is int;\nusing {op.RedLib.toScore, op.RedLib.exp, op.addRed as +, op.mulRed as *, op.unsubRed as -} for Red global;\nusing {op.lteRed as <=, op.gtRed as >} for Red global;\n\ntype Blue is int;\nusing {\n    op.addBlue as +,\n    op.unsubBlue as -,\n    op.subBlue as -,\n    op.BlueLib.toScore,\n    op.lteBlue as <=,\n    op.gtBlue as >\n} for Blue global;\n\ntype Score is int128;\nusing {op.addScore as +} for Score global;\nusing {op.subScore as -} for Score global;\nusing {op.divScore as /} for Score global;\n\nRed constant RED_LIMIT = Red.wrap(10);\nBlue constant BLUE_LIMIT = Blue.wrap(20);\n```\n\n`operators.sol`\n\n```solidity\npragma solidity ^0.8.19;\n\nimport {Red, Blue, Score} from \"./types.sol\";\n\nlibrary RedLib {\n    function toScore(Red x) internal pure returns (Score) {\n        return Score.wrap(int128(Red.unwrap(x))) + Score.wrap(10);\n    }\n\n    function exp(Red x, uint y) internal pure returns (Red) {\n        return Red.wrap(Red.unwrap(x) ** y);\n    }\n}\n\nlibrary BlueLib {\n    function toScore(Blue x) internal pure returns (Score) {\n        return Score.wrap(int128(Blue.unwrap(x))) - Score.wrap(20);\n    }\n\n    function add(Blue x, Blue y) external pure returns (Blue) {\n        return Blue.wrap(Blue.unwrap(x) + Blue.unwrap(y));\n    }\n}\n\nusing {BlueLib.add} for Blue;\n\nfunction addRed(Red x, Red y) pure returns (Red)  { return Red.wrap(Red.unwrap(x) + Red.unwrap(y)); }\nfunction mulRed(Red x, Red y) pure returns (Red)  { return Red.wrap(Red.unwrap(x) * Red.unwrap(y)); }\nfunction unsubRed(Red x)      pure returns (Red)  { return Red.wrap(-Red.unwrap(x)); }\nfunction lteRed(Red x, Red y) pure returns (bool) { return Red.unwrap(x) <= Red.unwrap(y); }\nfunction gtRed(Red x, Red y)  pure returns (bool) { return !(x <= y); }\n\nfunction addBlue(Blue x, Blue y) pure returns (Blue) { return x.add(y); }\nfunction unsubBlue(Blue x)       pure returns (Blue) { return Blue.wrap(-Blue.unwrap(x)); }\nfunction subBlue(Blue x, Blue y) pure returns (Blue) { return x + -y; }\nfunction lteBlue(Blue x, Blue y) pure returns (bool) { return Blue.unwrap(x) <= Blue.unwrap(y); }\nfunction gtBlue(Blue x, Blue y)  pure returns (bool) { return !(x <= y); }\n\nfunction addScore(Score x, Score y) pure returns (Score) { return Score.wrap(Score.unwrap(x) + Score.unwrap(y)); }\nfunction subScore(Score x, Score y) pure returns (Score) { return Score.wrap(Score.unwrap(x) - Score.unwrap(y)); }\nfunction divScore(Score x, Score y) pure returns (Score) { return Score.wrap(Score.unwrap(x) / Score.unwrap(y)); }\n```\n\n### AST Changes\n\nThe new feature introduces two new attributes to the Abstract Syntax Tree (AST) produced by the compiler:\n\n1. `functionList` on `UsingForDirective` nodes can now contain operator entries of the following structure:\n   ```json\n   {\n     \"operator\": \"+\",\n     \"definition\": {\n       /* function */\n     }\n   }\n   ```\n   in addition to the current entries for functions that are structured as follows:\n   ```json\n   {\n     \"function\": {\n       /* function */\n     }\n   }\n   ```\n1. `BinaryOperation` and `UnaryOperation` nodes may now have a `function` attribute.\n   If present, the attribute indicates that the operation is actually an invocation of a user-defined\n   operator and specifies the ID of the function used to define it.\n\nThis effectively introduces a new way to perform a function call not represented by a `FunctionCall` node.\nIt will affect any tool that needs to detect and follow function calls, for example, to build a\ncontrol flow graph.\n\n### Design Rationale\n\n#### Why Does Solidity Need User-Defined Operators?\n\nThe support for user-defined value types in Solidity cannot be considered complete without more natural\nways to operate on them.\nThe ability to use operators was envisioned from the beginning, and the main reason it was not provided\nimmediately was the uncertainty regarding interactions with other features we plan to introduce.\nWe decided that it was best to release the feature in a minimal usable state and extend it over time,\ntaking into account user feedback.\n\nUDVTs in general were meant to fulfill two needs:\n\n1. More type-safety when performing operations on values of the same underlying value type that express\n   conceptually different things.\n   For example quantities of different dimensions could both be stored as `uint` but adding them without\n   an explicit conversion is a mistake that can only be prevented if the compiler knows that they\n   are values of different kinds.\n\n1. The ability to define new types using value types as the underlying representation.\n   The best example of this are fixed-point types.\n\n   Fixed-point types were originally planned to be an integral part of the language, and the\n   partially implemented [`ufixed` and `fixed`](https://docs.soliditylang.org/en/latest/types.html#fixed-point-numbers)\n   types are the vestiges of that old design.\n   While trying to agree on the final design for the feature, however, we realized that no implementation\n   will be a good enough trade-off for most situations and cannot become a suitable default choice.\n   We decided to leave the choice up to library authors and instead focus on providing primitives\n   necessary to build their own fixed-point types that feel like native types.\n   User-defined operators are a step towards that goal.\n\n#### Will User-Defined Operators Make Auditing Harder?\n\nIn the feedback we received so far one of the most common concerns is the effect of the feature on contract\nauditing and potential to mask malicious code.\nWe want to address these concerns here.\n\nFirst of all, any new syntax increases the complexity of the language and has some potential to make code more obscure\nand harder to understand when abused.\nIt cannot be completely avoided and is always a trade-off between all the good and bad ways it can be used.\nWe think that improving the ergonomics of UDVTs is important enough that it outweighs any of the downsides we considered.\n\nThe readability benefits provided by operators cannot be overstated.\nCode containing even relatively simple expressions can be hard to understand at a glance when many function calls are involved:\n\n```solidity\nif (equals(add(mul(a, x), mul(b, y)), add(div(c, z), mod(d, w)))) {\n    return add(div(c, z), mod(d, w));\n}\n```\n\nChaining attached functions somewhat helps by placing the operation name between the arguments (similar to an infix operator):\n\n```solidity\nif (a.mul(x).add(b.mul(y)).equals(c.div(z).add(d.mul(w)))) {\n    return c.div(z).add(d.mod(w)));\n}\n```\n\nIt is, however, still a far cry from the clean, concise notation that can be achieved with the use of operators:\n\n```solidity\nif (a * x + b * y == c / z + d % w) {\n    return c / z + d % w;\n}\n```\n\nThe last example is how we would prefer real code to look like.\nBy the way, did you spot the mistake in the second example?\n\nIt is also essential to realize the actual scope of the feature.\nYou may imagine an elaborate system from languages like C++, with complicated rules and many corner cases.\nAs implemented now the feature is deliberately very limited.\nWe tried both to limit surprises and to avoid prematurely adding support for cases that we have not carefully thought out.\n\nIn the current implementation, it is not possible to:\n\n1. Have operators on types other than UDVTs.\n   - User-defined operators on [reference types](https://docs.soliditylang.org/en/latest/types.html#reference-types)\n     like structs or arrays are not allowed.\n   - It is not possible to define them on built-in value types, function types or enums.\n   - You cannot define them to unnamed types using the type wildcard (`*`).\n1. Have operators that are not `pure`.\n   Operators cannot modify storage.\n   They can, at most, make pure external calls.\n\n   The worst that is technically possible with tricks is for them to modify memory (only through inline assembly)\n   or make staticcalls (through interfaces that do not match deployed code).\n\n1. Have operators on mixed types.\n   Parameter and return value types of operators must be the same.\n   Also, no implicit conversions are possible, so it is very simple to determine if a particular operation\n   will invoke a user-define operator or a built-in one (just look at the type).\n1. Redefine operators.\n   You cannot replace any of the built-in operators with a custom definition.\n   For user-defined operators, only one definition can be provided.\n1. Bind operators to contract functions.\n   This also means that operator definitions cannot be inherited, virtual, or remain unimplemented.\n1. Bind operators to overloaded functions.\n1. Use built-in functions to define operators.\n   You cannot e.g. bind an operator directly to `keccak256()`.\n1. Change the precedence or associativity of an operator.\n1. Define any of the operators with more complex semantics.\n   You cannot define:\n   - `&&` and `||` due to their short-circuiting behavior.\n   - `++` and `--` because they modify their argument and also have separate prefix and postfix variants with different semantics.\n   - `+=`, `-=`, `^=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=` because they modify their argument.\n   - `=`, `()`, `?:`, and `.` because they are built-in for all types.\n   - `delete`, `new`, and `[]` because they are not usable with UDVTs.\n1. Define custom operators that do not exist in the language, like `===` or unary `+`.\n1. Bind operators in bulk or accidentally.\n   The `using L for T` syntax for attaching a whole library to a type does not cover operators.\n   Operators must always be bound explicitly.\n\nIn addition to these restrictions, we decided to limit them even more in response to feedback we received before releasing Solidity 0.8.18.\nThis means you also cannot:\n\n1. Use library functions to define operators.\n   This excludes external, public, and private functions.\n   It is also now impossible to apply modifiers to operators because free functions cannot have them.\n1. Have non-global operators, which has several consequences:\n   - Operators can only be bound in the file that also defines the type.\n     They are available wherever the type is available and cannot have different definitions in different scopes.\n   - Local bindings at contract level are not possible (i.e. inside contracts and libraries).\n     This also makes it impossible to define operators for local types that are defined inside contracts or libraries.\n1. Define `!`, `<<`, `>>` and `**`.\n\nWe may lift _some_ of these restrictions in the future, but we will consider every case carefully.\nSome of them, like the inability to use overloaded functions, stem from pre-existing limitations of the syntax, but\nothers, like a ban on redefining built-in operators, are very intentional and meant to limit potential misuse.\n\nIn the end, any audit must include a careful review of type definitions and functions, and we think\nthat this will reveal most cases of malicious behavior.\nGiven the above limitations, bad operators cannot do much more than mislead, which is something that\nwill come up in the review of the definition.\nWeird behavior, like `+` that does anything other than perform addition should raise a red flag,\njust like a function called `transfer()` that does not transfer anything.\n\nReviewing the invocations of an operator should not pose significant problems either, as long as\nthe reviewer is aware of the types involved, which is always necessary to understand the expression.\nThis is not a new thing, since the behavior of the built-in operators has always been affected by operand types.\nFor example the overflow semantics of integer types depend on the size of the type in question.\n\nNote that user-defined operators cannot alter semantics of the existing code.\nFor built-in types behavior cannot be altered at all.\nFor UDVTs any operator must necessarily be user-defined so seeing it is not much different from\nseeing a function call.\nAn operator can have only one definition, the definition must be explicitly bound in the file that\ndefines the type and cannot be shadowed.\nIn both cases the name may be misleading and a look at the definition may be necessary.\n\nIt is also worth noting that the feature is meant to be predominantly used in reusable libraries providing common types.\nIn this context, once the library is audited, the concern about operators having misleading or unexpected behavior should be minimal.\n\n### The Future of User-Defined Operators and UDVTs\n\nNow that we know the new feature and its limitations, the question on everyone's mind is probably\n\"Will it stay that way?\".\nHow will the feature evolve in the short and long term?\n\n#### Literal Suffixes\n\nThe very next step for UDVTs is the ability to provide custom literals of user-defined value types.\nThe ease of using literal values in expressions is a big part of what makes a type feel native.\nSolidity already provides fractional literals and our intention is to make them usable with custom\nfixed-point number implementations.\nTo achieve that we are going to allow defining suffix functions that return UDVT by converting\nliterals that are already available in the language:\n\n```solidity\ntype UFixed128x18 is uint128;\n\nfunction uf(int16 mantissa, uint8 exponent) pure suffix returns (UFixed128x18) { ... }\n```\n\n```solidity\nUFixed128x18 circumference = 2 uf * 3.14 uf * radius;\n```\n\nWhile the application of a suffix will involve a function call, eventually, with the help of\ncompile-time evaluation, literal suffixes are going to become as efficient as native literals.\n\n#### More Operators\n\nMany operators have been excluded from the initial implementation.\nSome of them will very likely be user-definable at some point:\n\n1. `<<`, `>>` and `**` were excluded due to their non-uniform arguments.\n   For built-in types, the right-hand side is always an unsigned type.\n1. `!` was excluded because we have to decide whether it should return the same type as the argument\n   or just `bool`.\n   We are leaning towards the latter, but it needs more consideration.\n1. `++` and `--` are very convenient, and we want to have them eventually.\n   They just need to be handled in a special way, and there is more than way to do so.\n1. Composite assignment operators, such as `+=`, will likely be provided automatically\n   in the future as long as the corresponding arithmetic/bitwise operator is available.\n   Allowing a direct implementation is currently not possible anyway, because there are no references\n   to value types in the language.\n\nOn the other hand, it is unlikely that we will allow redefining some other operators:\n\n1. `=` is already provided by the compiler for all types and it is very unlikely that we will ever allow redefining it.\n\n#### Operators on Complex Types\n\nWhile UDVTs were the primary target, in some cases it may also be reasonable to build a custom type\nwith a more complex underlying representation, such as a struct or a dynamic array.\nThe main thing holding us back here are upcoming changes to the type system that are a significant part\nof our roadmap for the near future.\nTo avoid having to introduce breaking changes later, we decided to defer support for such operators until\nthese changes are behind us.\n\n#### What Will Not Change?\n\nDue to concerns about the safety of the feature, there are some key elements that are very unlikely to ever change regarding operators.\nOperators will likely always be global and defined at file level with free functions.\nIt will not be possible to replace built-in opertors or redefine already defined user-defined operators.\n","availableURLs":["/2023/05/10/solidity-0.8.20-release-announcement","/2023/03/10/solidity-developer-survey-2022-results","/2023/02/22/user-defined-operators","/2023/02/22/solidity-0.8.19-release-announcement","/2023/02/01/solidity-0.8.18-release-announcement","/2022/12/07/solidity-developer-survey-2022-announcement","/2022/12/05/solidity-core-team-updates","/2022/09/08/storage-write-removal-before-conditional-termination","/2022/09/08/solidity-0.8.17-release-announcement","/2022/08/08/solidity-0.8.16-release-announcement","/2022/08/08/calldata-tuple-reencoding-head-overflow-bug","/2022/06/15/solidity-0.8.15-release-announcement","/2022/06/15/inline-assembly-memory-side-effects-bug","/2022/06/15/dirty-bytes-array-to-storage-bug","/2022/05/17/solidity-0.8.14-release-announcement","/2022/05/17/data-location-inheritance-bug","/2022/05/17/calldata-reencode-size-check-bug","/2022/05/03/solidity-summit-2022-recap","/2022/04/08/announcing-the-underhanded-contest-winners-2022","/2022/03/16/solidity-0.8.13-release-announcement","/2022/03/16/encodecall-bug","/2022/02/22/solidity-summit-2022-announcement","/2022/02/16/solidity-0.8.12-release-announcement","/2022/02/09/underhanded-solidity-contest-2022-announcement","/2022/02/07/solidity-developer-survey-2021-results","/2021/12/20/solidity-0.8.11-release-announcement","/2021/11/18/solidity-developer-survey-2021","/2021/11/09/solidity-0.8.10-release-announcement","/2021/09/29/user-defined-value-types-bug","/2021/09/29/solidity-0.8.9-release-announcement","/2021/09/29/signed-immutables-bug","/2021/09/27/user-defined-value-types","/2021/09/27/solidity-0.8.8-release-announcement","/2021/08/11/solidity-0.8.7-release-announcement","/2021/06/22/solidity-0.8.6-release-announcement","/2021/06/10/solidity-0.8.5-release-announcement","/2021/05/03/soliditylangorg-umbrella-domain","/2021/04/21/solidity-0.8.4-release-announcement","/2021/04/21/decoding-from-memory-bug","/2021/04/21/custom-errors","/2021/04/01/announcing-solidity-collectibles","/2021/03/23/solidity-0.8.3-release-announcement","/2021/03/23/keccak-optimizer-bug","/2021/03/02/solidity-0.8.2-release-announcement","/2021/03/02/saving-gas-with-simple-inliner","/2021/02/15/contributing-to-solidity-101","/2021/02/10/an-introduction-to-soliditys-fuzz-testing-approach","/2021/02/01/launching-the-solidity-forum","/2021/01/27/solidity-0.8.1-release-announcement","/2021/01/26/solidity-developer-survey-2020-results","/2020/12/16/solidity-v0.8.0-release-announcement","/2020/12/16/solidity-0.7.6-release-announcement","/2020/12/09/solidity-developer-survey-2020","/2020/12/03/solidity-underhanded-contest-winners","/2020/11/18/solidity-0.7.5-release-announcement","/2020/11/04/solidity-ama-1-recap","/2020/10/28/solidity-0.8.x-preview","/2020/10/19/solidity-0.7.4-release-announcement","/2020/10/19/empty-byte-array-copy-bug","/2020/10/07/solidity-dynamic-array-cleanup-bug","/2020/10/07/solidity-0.7.3-release-announcement","/2020/09/28/solidity-0.7.2-release-announcement","/2020/09/21/solidity-underhanded-contest","/2020/09/18/meet-the-team","/2020/09/02/solidity-0.7.1-release-announcement","/2020/07/28/solidity-v0.7.0-release-announcement","/2020/07/22/Solidity-0612-release-announcement","/2020/07/08/solidity-turns-5","/2020/07/07/Solidity-0611-release-announcement","/2020/06/25/sourcify-faq","/2020/06/18/solidity-0.6-inheritance","/2020/06/11/Solidity-0610-release-announcement","/2020/06/09/solidity-summit-recap","/2020/06/05/Solidity-069-release-announcement","/2020/06/02/Sourcify-Towards-Safer-Contract-Interaction-for-Humans","/2020/05/26/array-slices","/2020/05/14/Solidity-068-release-announcement","/2020/05/13/immutable-keyword","/2020/05/04/solidity-0.6.7-release-announcement","/2020/04/17/Solidity-Summit-2020-Goes-Interspace","/2020/04/09/solidity-0.6.6-release-announcement","/2020/04/06/solidity-0.6.5-release-announcement","/2020/04/06/memory-creation-overflow-bug","/2020/03/23/fallback-receive-split","/2020/03/17/solidity-0.5.17-release-announcement","/2020/03/10/solidity-0.6.4-release-announcement","/2020/02/18/solidity-0.6.3-release-announcement","/2020/01/29/solidity-0.6-try-catch","/2020/01/27/solidity-0.6.2-release-announcement","/2020/01/02/solidity-0.6.1-release-announcement","/2020/01/02/solidity-0.5.16-release-announcement","/2019/12/17/solidity-0.6.0-release-announcement","/2019/12/17/solidity-0.5.15-release-announcement","/2019/12/09/solidity-0.5.14-release-announcement","/2019/11/14/solidity-0.5.13-release-announcement","/2019/10/01/solidity-0.5.12-release-announcement","/2019/08/12/solidity-0.5.11-release-announcement","/2019/06/25/solidity-storage-array-bugs","/2019/06/25/solidity-0.5.10-release-announcement","/2019/05/28/solidity-0.5.9-release-announcement","/2019/04/30/solidity-0.5.8-release-announcement","/2019/04/29/solidity-0.4.26-release-announcement","/2019/03/26/solidity-optimizer-and-abiencoderv2-bug","/2019/03/26/solidity-0.5.7-release-announcement","/2019/03/13/solidity-0.5.6-release-announcement","/2019/03/05/solidity-0.5.5-release-announcement","/2019/02/12/solidity-0.5.4-release-announcement","/2019/01/22/solidity-0.5.3-release-announcement","/2018/12/19/solidity-0.5.2-release-announcement","/2018/12/03/solidity-0.5.1-release-announcement","/2018/11/13/solidity-0.5.0-release-announcement","/2018/09/13/solidity-bugfix-release","/2018/09/13/solidity-0.4.25-release-announcement","/2018/05/16/solidity-0.4.24-release-announcement","/2018/04/19/solidity-0.4.23-release-announcement","/2018/04/17/solidity-0.4.22-release-announcement","/2018/03/08/solidity-0.4.21-release-announcement","/2018/02/14/solidity-0.4.20-release-announcement","/2017/11/30/solidity-0.4.19-release-announcement","/2017/10/18/solidity-0.4.18-release-announcement","/2017/09/21/solidity-0.4.17-release-announcement","/2017/08/24/solidity-0.4.16-release-announcement","/2017/08/08/solidity-0.4.15-release-announcement","/2017/07/31/solidity-0.4.14-release-announcement","/2017/07/06/solidity-0.4.13-release-announcement","/2017/07/03/solidity-0.4.12-release-announcement","/2017/05/03/solidity-optimizer-bug","/2017/05/03/solidity-0.4.11-release-announcement","/2017/03/15/solidity-0.4.10-release-announcement","/2017/01/31/solidity-0.4.9-release-announcement","/2017/01/13/solidity-0.4.8-release-announcement","/2016/12/15/solidity-0.4.7-release-announcement","/2016/11/22/solidity-0.4.6-release-announcement","/2016/11/21/solidity-0.4.5-release-announcement","/2016/11/09/analysis-storage-corruption-bug","/2016/11/01/solidity-0.4.4-release-announcement","/2016/11/01/security-alert-solidity-variables-can-overwritten-storage","/2016/10/25/solidity-0.4.3-release-announcement","/2016/09/17/solidity-0.4.2-release-announcement","/2016/09/09/solidity-0.4.1-release-announcement","/2016/09/08/solidity-0.4.0-release-announcement","/2016/09/01/formal-methods-roadmap","/2016/08/10/solidity-0.3.6-release-announcement","/2016/06/10/solidity-0.3.5-release-announcement","/2016/06/10/smart-contract-security","/2016/05/31/solidity-0.3.4-release-announcement","/2016/05/27/solidity-0.3.3-release-announcement","/2016/04/18/solidity-0.3.2-release-announcement","/2016/03/31/solidity-0.3.1-release-announcement","/2016/03/11/solidity-0.3.0-release-announcement","/2016/02/17/solidity-0.2.2-release-announcement","/2016/01/30/solidity-0.2.1-release-announcement","/2015/12/01/solidity-0.2.0-release-announcement","/2015/11/17/solidity-0.1.7-release-announcement","/2015/10/16/solidity-0.1.6-release-announcement","/2015/10/07/solidity-0.1.5-release-announcement","/2015/09/30/solidity-0.1.4-release-announcement","/2015/09/22/solidity-0.1.3-release-announcement","/2015/08/21/solidity-0.1.2-release-announcement"]},"__N_SSG":true}