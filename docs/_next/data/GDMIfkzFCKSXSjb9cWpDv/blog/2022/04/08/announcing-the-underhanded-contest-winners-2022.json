{"pageProps":{"frontmatter":{"layout":"post","published":true,"title":"Announcing the Winners of the Underhanded Solidity Contest 2022","date":"2022-04-09","author":"Franziska Heintel & USC Judges","category":"Announcements"},"content":"\nThe time has come to share this year's winners of the [Underhanded Solidity Contest](https://underhanded.soliditylang.org/)!\n\nBefore we dive into the winning submissions, let's revisit the most important features of the USC:\n\nIn a nutshell, the USC is about finding loopholes or ‚Äúhiding spots‚Äù in the Solidity language and using those to write seemingly innocent and straightforward-looking Solidity code which contains malicious behavior or backdoors.\n\nThe Underhanded Solidity Contest aims to...\n\n- Raise awareness about smart contract security.\n- Uncover language design faults.\n- Battle-test recently introduced language features and restrictions.\n- Highlight anti-patterns in smart contact development.\n- Establish new best practices for secure smart contract development.\n\nEach contest has a different theme or topic. [This year](https://blog.soliditylang.org/2022/02/09/underhanded-solidity-contest-2022-announcement/), the task was to build a decentralized exchange that looks fair, but can be ‚Äúmanipulated‚Äù.\n\nIn total, we received 19 submissions, 18 of which are eligible for a ‚Äúqualified submission‚Äù Underhanded Solidity POAP NFT. You can find all 18 qualified submissions in [this repo](https://github.com/ethereum/solidity-underhanded-contest/tree/master/2022/submissions_2022).\n\nA big thank you and props to all participants for taking part!\n\nAs always, the judges were presented with anonymized submissions and only after the judging process was finished, the identities of the participants were disclosed.\n\nNow, without further ado, let's take a look at the winners, starting with the 3rd place!\n\n## Underhanded Solidity Contest 2022 Winners\n\n### ü•â Third Place: [Michael Zhu](https://github.com/ethereum/solidity-underhanded-contest/tree/master/2022/submissions_2022/submission17_MichaelZhu)\n\n_commentary by [samczsun](https://twitter.com/samczsun)_\n\nThis submission is a simple but elegant reminder that not everything is as it seems. The contract implements a very simple NFT sale mechanism where buyers can place bids and sellers can accept them. For optimization purposes, the addresses of the two assets (the NFT being purchased and the token used for purchasing) are XOR'ed together to form a single unique key. The comments helpfully remind us that the odds of finding another pair of contract addresses which collide to the same key is statistically impossible.\n\nWhen a bid is accepted, `safeTransferFrom` is used to move the payment from the bidder to the sender, and `transferFrom` is used to move the NFT from the sender to the bidder. However, both ERC20 and ERC721 define a `transferFrom` function with the same parameters, which leads to them having the same selector. Furthermore, `safeTransferFrom` will succeed even if the token does not strictly comply with the ERC20 spec and returns no boolean. Finally, though it may be obvious to some, XOR is a commutative operation. Therefore, it's possible to accept a fake bid by swapping the ERC20 and ERC721 addresses when accepting a bid. This causes the NFT, rather than the payment token, to be transferred from the bidder. Clearly this is an undesirable result.\n\nAlthough in its simplified form, the underhanded nature of the optimization might be easily spotted (especially in the context of an underhanded competition), we think that it acts as a good proxy for teaching users how to look past what the code and comments might suggest and read between the lines. Similar methods of thinking lead to the discovery of the Anyswap exploit, and to a lesser extent, the various \"fake contract\" exploits.\n\n### ü•à Second Place: [Santiago Palladino](https://github.com/ethereum/solidity-underhanded-contest/tree/master/2022/submissions_2022/submission10_SantiagoPalladino)\n\n_commentary by [Hari Mulackal](https://twitter.com/_hrkrshnn)_\n\nThe submission demonstrates what could go wrong if a non-standard signature scheme is used in contracts. The contract cleverly designs the `Order` struct in such a way that it can collide with the RLP encoding of an `approve` transaction. This allows an attacker to reuse the signature for the `approve` transaction to execute an order in the exchange!\n\nThere are several other issues with the implementation, and we leave it up to the reader to uncover all of them!\n\n### ü•á First Place: [Tynan Richards](https://github.com/ethereum/solidity-underhanded-contest/tree/master/2022/submissions_2022/submission9_TynanRichards)\n\n_commentary by [Duncan Townsend](https://twitter.com/duncancmt)_\n\nThis submission is subtle. Very subtle. Nobody on our judging panel was able to\nspot the trick without the help of the spoiler file. Although the behavior\nexploited here is explicitly documented in the Solidity docs, it's absolutely not something\nthat programmers or security experts consider in their day-to-day.\n\nOn its face, this submission is a reasonably well implemented constant-product\nAMM. For those familiar with this kind of DEX, you'll probably recognize the\nformulas used for adding and removing liquidity, as well as the formula for\ntaking a fee on the swap. This AMM pair helpfully includes the logic required to\ncalculate input and output amounts without the help of a router. There are a\nnumber of security concerns that an auditor might catch in this contract that\nare not the core, catastrophic vulnerability that we're looking for here.\n\nIn order of least severe to most, some vulnerabilities caught by the judges are:\n\n- There's no ability for this AMM to provide a time-weighted average price\n  oracle (or other form of manipulation resistant price oracle).\n- Liquidity isn't tokenized and can only be withdrawn by the same address that\n  provided it.\n- The implementation of `sqrt` doesn't use the more common [Babylonian method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n  and instead uses [Newton-Raphson](https://en.wikipedia.org/wiki/Newton%27s_method) to converge\n  on the correct value.\n- `transferFundsIn` and `transferFundsOut` don't support ERC20 tokens that\n  return nothing from their `transferFrom` and `transfer` functions. This is a\n  common deviation from [the standard](https://eips.ethereum.org/EIPS/eip-20),\n  which requires that those functions return `bool`. The various iterations of\n  `SafeERC20` typically handle this.\n- There's no function for synchronizing the internal balances/reserves of the\n  contract with its actual balances. If tokens move into or out of the contract\n  outside of `transferFundsIn` or `transferFundsOut` (like a rebase or a direct\n  call to `transfer`), that change in balances won't be accounted for.\n- There's no protection against loss-of-precision vulnerabilities in\n  `addLiquidity` which reduces ratio of `totalSupply` to liquidity. However,\n  this is effectively mitigated by the previous flaw.\n- There's no slippage parameter in `trade`, `addLiquidity`, or\n  `removeLiquidity`, all of which can result in DEX interactions being\n  [sandwiched](https://cmichel.io/de-fi-sandwich-attacks/) and the trader\n  receiving a reduced payout.\n\nThe actual trick is far more catastrophic than any of these. The vulnerability\nlives in the way that admin fees are claimed. The author of this contract has\nhelpfully added a way for liquidity providers to exit the DEX if the admin of\nthe DEX sets the admin fee too large. A new admin fee can be scheduled, but it\nwon't take effect for 7 days, allowing liquidity providers to exit. However,\nthis protection is implemented wrong in a subtle and catastrophic way.\n\nIn Solidity, the order of evaluation of sub-expressions is _unspecified_. This\nmeans that in `f(g(), h())`, `g()` might get evaluated before `h()` or `h()`\nmight get evaluated before `g()`. Practically, this order is predictable, but\nSolidity code shouldn't depend on that behavior between compiler versions. In\n_most_ circumstances `g()` is evaluated before `h()` (left-to-right order),\nwhich is also the behavior that most languages specify in their\nstandards. However, in the case of emitting an event with indexed arguments, the\narguments are evaluated right-to-left.\n\nTherefore, when the admin calls `changeAdminFees`, `setNewAdminFee` is evaluated\n_before_ `retireOldAdminFee`. Since `retireOldAdminFee` calls `_claimAdminFees`,\nthe new fee is enacted before the tokens are accounted and transferred. The\n`require` on line 67 is effectively useless because the 7-day delay in\n`nextFeeClaimTimestamp` hasn't been set yet. Additionally, there's no cap on\n`newAdminFee`. It can bet set above `ONE` (10\\*\\*18), so it can be set high enough\nthat the _entire_ balance/reserves of the trading pair can be drained by the\nadmin.\n\nAlthough this submission is long and contains many red herrings, the judges\nchose it as our USC 2022 winner because of how the flaw is hidden in plain\nsight. A good unit test or fuzzer would definitely find this vulnerability, but\nmanual code review was unable to catch it. We applied the standard that a\nsuccessful USC submission is one that could trick a careful smart contract\ndeveloper into trusting it with their money, only to steal it anyways. In that\nregard, this contract is an absolute winner. Additionally, this submission\nhighlights an aspect of Solidity that most developers and auditors are probably\nunaware of. Order of evaluation of subexpressions doesn't usually matter, but in\nthis case, it makes all the difference.\n\nAnd here is [that documentation I\npromised](https://docs.soliditylang.org/en/v0.8.13/control-structures.html#order-of-evaluation-of-expressions).\n\n## Honorable Mentions\n\n### üíê [William Bowling](https://github.com/ethereum/solidity-underhanded-contest/tree/master/2022/submissions_2022/submission4_WilliamBowling)\n\n_commentary by [Anton Permenev](https://twitter.com/a_permenev)_\n\nWith Solidity v0.8, developers don't have to think about the overflow in arithmetic operations.\n\nThis submission is a good reminder that bit shift `<<` and `>>` operators are not among the arithmetic ones, and thus don't revert on overflow.\n\nHowever, such operators are quite rare and their usage is suspicious and raises eyebrows.\n\n## Trick us at the next Underhanded Solidity Contest, anon!\n\nOnce again, the Underhanded Solidity Contest showed interesting anti-patterns and intriguing ways to embed malicious exploits into smart contract systems. We can't wait to see what you come up with next time!\n\nThanks to [ChainSecurity](https://chainsecurity.com/), [ConsenSys Diligence](https://diligence.consensys.net/), [Immunefi](https://immunefi.com/), [Solidified](https://solidified.io/), [Trail of Bits](https://www.trailofbits.com/), [Paradigm](https://www.paradigm.xyz/), the [Ethereum Foundation](https://ethereum.foundation/) for their support!\n\nLast but not least, we'd like to extend a big thank you to our amazing judges for helping us make this contest happen: Alex Beregszaszi, Anton Permenev, Duncan Townsend, Gon√ßalo S√°, Hari Mulackal, Josselin Feist, samczsun and Stefan Beyer. üëè\n\nWould you like to propose a topic for the next Underhanded Solidity Contest, provide feedback, or help with judging the next time? Then feel free to reach out to us at `sol_underhanded@ethereum.org`!\n\n_We will be in touch with all participants shortly with details on the claiming process for the NFTs as well as the main prizes._\n","availableURLs":["/2023/05/10/solidity-0.8.20-release-announcement","/2023/03/10/solidity-developer-survey-2022-results","/2023/02/22/user-defined-operators","/2023/02/22/solidity-0.8.19-release-announcement","/2023/02/01/solidity-0.8.18-release-announcement","/2022/12/07/solidity-developer-survey-2022-announcement","/2022/12/05/solidity-core-team-updates","/2022/09/08/storage-write-removal-before-conditional-termination","/2022/09/08/solidity-0.8.17-release-announcement","/2022/08/08/solidity-0.8.16-release-announcement","/2022/08/08/calldata-tuple-reencoding-head-overflow-bug","/2022/06/15/solidity-0.8.15-release-announcement","/2022/06/15/inline-assembly-memory-side-effects-bug","/2022/06/15/dirty-bytes-array-to-storage-bug","/2022/05/17/solidity-0.8.14-release-announcement","/2022/05/17/data-location-inheritance-bug","/2022/05/17/calldata-reencode-size-check-bug","/2022/05/03/solidity-summit-2022-recap","/2022/04/08/announcing-the-underhanded-contest-winners-2022","/2022/03/16/solidity-0.8.13-release-announcement","/2022/03/16/encodecall-bug","/2022/02/22/solidity-summit-2022-announcement","/2022/02/16/solidity-0.8.12-release-announcement","/2022/02/09/underhanded-solidity-contest-2022-announcement","/2022/02/07/solidity-developer-survey-2021-results","/2021/12/20/solidity-0.8.11-release-announcement","/2021/11/18/solidity-developer-survey-2021","/2021/11/09/solidity-0.8.10-release-announcement","/2021/09/29/user-defined-value-types-bug","/2021/09/29/solidity-0.8.9-release-announcement","/2021/09/29/signed-immutables-bug","/2021/09/27/user-defined-value-types","/2021/09/27/solidity-0.8.8-release-announcement","/2021/08/11/solidity-0.8.7-release-announcement","/2021/06/22/solidity-0.8.6-release-announcement","/2021/06/10/solidity-0.8.5-release-announcement","/2021/05/03/soliditylangorg-umbrella-domain","/2021/04/21/solidity-0.8.4-release-announcement","/2021/04/21/decoding-from-memory-bug","/2021/04/21/custom-errors","/2021/04/01/announcing-solidity-collectibles","/2021/03/23/solidity-0.8.3-release-announcement","/2021/03/23/keccak-optimizer-bug","/2021/03/02/solidity-0.8.2-release-announcement","/2021/03/02/saving-gas-with-simple-inliner","/2021/02/15/contributing-to-solidity-101","/2021/02/10/an-introduction-to-soliditys-fuzz-testing-approach","/2021/02/01/launching-the-solidity-forum","/2021/01/27/solidity-0.8.1-release-announcement","/2021/01/26/solidity-developer-survey-2020-results","/2020/12/16/solidity-v0.8.0-release-announcement","/2020/12/16/solidity-0.7.6-release-announcement","/2020/12/09/solidity-developer-survey-2020","/2020/12/03/solidity-underhanded-contest-winners","/2020/11/18/solidity-0.7.5-release-announcement","/2020/11/04/solidity-ama-1-recap","/2020/10/28/solidity-0.8.x-preview","/2020/10/19/solidity-0.7.4-release-announcement","/2020/10/19/empty-byte-array-copy-bug","/2020/10/07/solidity-dynamic-array-cleanup-bug","/2020/10/07/solidity-0.7.3-release-announcement","/2020/09/28/solidity-0.7.2-release-announcement","/2020/09/21/solidity-underhanded-contest","/2020/09/18/meet-the-team","/2020/09/02/solidity-0.7.1-release-announcement","/2020/07/28/solidity-v0.7.0-release-announcement","/2020/07/22/Solidity-0612-release-announcement","/2020/07/08/solidity-turns-5","/2020/07/07/Solidity-0611-release-announcement","/2020/06/25/sourcify-faq","/2020/06/18/solidity-0.6-inheritance","/2020/06/11/Solidity-0610-release-announcement","/2020/06/09/solidity-summit-recap","/2020/06/05/Solidity-069-release-announcement","/2020/06/02/Sourcify-Towards-Safer-Contract-Interaction-for-Humans","/2020/05/26/array-slices","/2020/05/14/Solidity-068-release-announcement","/2020/05/13/immutable-keyword","/2020/05/04/solidity-0.6.7-release-announcement","/2020/04/17/Solidity-Summit-2020-Goes-Interspace","/2020/04/09/solidity-0.6.6-release-announcement","/2020/04/06/solidity-0.6.5-release-announcement","/2020/04/06/memory-creation-overflow-bug","/2020/03/23/fallback-receive-split","/2020/03/17/solidity-0.5.17-release-announcement","/2020/03/10/solidity-0.6.4-release-announcement","/2020/02/18/solidity-0.6.3-release-announcement","/2020/01/29/solidity-0.6-try-catch","/2020/01/27/solidity-0.6.2-release-announcement","/2020/01/02/solidity-0.6.1-release-announcement","/2020/01/02/solidity-0.5.16-release-announcement","/2019/12/17/solidity-0.6.0-release-announcement","/2019/12/17/solidity-0.5.15-release-announcement","/2019/12/09/solidity-0.5.14-release-announcement","/2019/11/14/solidity-0.5.13-release-announcement","/2019/10/01/solidity-0.5.12-release-announcement","/2019/08/12/solidity-0.5.11-release-announcement","/2019/06/25/solidity-storage-array-bugs","/2019/06/25/solidity-0.5.10-release-announcement","/2019/05/28/solidity-0.5.9-release-announcement","/2019/04/30/solidity-0.5.8-release-announcement","/2019/04/29/solidity-0.4.26-release-announcement","/2019/03/26/solidity-optimizer-and-abiencoderv2-bug","/2019/03/26/solidity-0.5.7-release-announcement","/2019/03/13/solidity-0.5.6-release-announcement","/2019/03/05/solidity-0.5.5-release-announcement","/2019/02/12/solidity-0.5.4-release-announcement","/2019/01/22/solidity-0.5.3-release-announcement","/2018/12/19/solidity-0.5.2-release-announcement","/2018/12/03/solidity-0.5.1-release-announcement","/2018/11/13/solidity-0.5.0-release-announcement","/2018/09/13/solidity-bugfix-release","/2018/09/13/solidity-0.4.25-release-announcement","/2018/05/16/solidity-0.4.24-release-announcement","/2018/04/19/solidity-0.4.23-release-announcement","/2018/04/17/solidity-0.4.22-release-announcement","/2018/03/08/solidity-0.4.21-release-announcement","/2018/02/14/solidity-0.4.20-release-announcement","/2017/11/30/solidity-0.4.19-release-announcement","/2017/10/18/solidity-0.4.18-release-announcement","/2017/09/21/solidity-0.4.17-release-announcement","/2017/08/24/solidity-0.4.16-release-announcement","/2017/08/08/solidity-0.4.15-release-announcement","/2017/07/31/solidity-0.4.14-release-announcement","/2017/07/06/solidity-0.4.13-release-announcement","/2017/07/03/solidity-0.4.12-release-announcement","/2017/05/03/solidity-optimizer-bug","/2017/05/03/solidity-0.4.11-release-announcement","/2017/03/15/solidity-0.4.10-release-announcement","/2017/01/31/solidity-0.4.9-release-announcement","/2017/01/13/solidity-0.4.8-release-announcement","/2016/12/15/solidity-0.4.7-release-announcement","/2016/11/22/solidity-0.4.6-release-announcement","/2016/11/21/solidity-0.4.5-release-announcement","/2016/11/09/analysis-storage-corruption-bug","/2016/11/01/solidity-0.4.4-release-announcement","/2016/11/01/security-alert-solidity-variables-can-overwritten-storage","/2016/10/25/solidity-0.4.3-release-announcement","/2016/09/17/solidity-0.4.2-release-announcement","/2016/09/09/solidity-0.4.1-release-announcement","/2016/09/08/solidity-0.4.0-release-announcement","/2016/09/01/formal-methods-roadmap","/2016/08/10/solidity-0.3.6-release-announcement","/2016/06/10/solidity-0.3.5-release-announcement","/2016/06/10/smart-contract-security","/2016/05/31/solidity-0.3.4-release-announcement","/2016/05/27/solidity-0.3.3-release-announcement","/2016/04/18/solidity-0.3.2-release-announcement","/2016/03/31/solidity-0.3.1-release-announcement","/2016/03/11/solidity-0.3.0-release-announcement","/2016/02/17/solidity-0.2.2-release-announcement","/2016/01/30/solidity-0.2.1-release-announcement","/2015/12/01/solidity-0.2.0-release-announcement","/2015/11/17/solidity-0.1.7-release-announcement","/2015/10/16/solidity-0.1.6-release-announcement","/2015/10/07/solidity-0.1.5-release-announcement","/2015/09/30/solidity-0.1.4-release-announcement","/2015/09/22/solidity-0.1.3-release-announcement","/2015/08/21/solidity-0.1.2-release-announcement"]},"__N_SSG":true}