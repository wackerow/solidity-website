{"pageProps":{"frontmatter":{"layout":"post","published":true,"title":"Optimizer Bug Regarding Memory Side Effects of Inline Assembly","date":"2022-06-15","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn June 5, 2022, [John Toman of the Certora development team reported an optimizer bug](https://medium.com/certora/overly-optimistic-optimizer-certora-bug-disclosure-2101e3f7994d)\nthat can cause memory writes in inline assembly blocks to be incorrectly removed\nunder certain conditions.\n\nThe bug was introduced in Solidity 0.8.13 with a new Yul optimizer step meant to\nremove unused writes to memory and storage.\n\nWe assigned the bug a severity of \"medium\".\n\n## Which Contracts are Affected?\n\nThe Yul optimizer considers all memory writes in the outermost Yul block that are\nnever read from as unused and removes them. This is valid when that Yul block is\nthe entire Yul program, which is always the case for the Yul code generated by the\nnew via-IR pipeline. Inline assembly blocks are never optimized in isolation when\nusing that pipeline. Instead they are optimized as a part of the whole Yul input.\n\nHowever, the legacy code generation pipeline (which is still the default) runs the\nYul optimizer individually on an inline assembly block if the block does not refer\nto any variables defined in the surrounding Solidity code. Consequently, memory\nwrites in such inline assembly blocks are removed as well, if the written memory is\nnever read from in the same assembly block, even if the written memory is accessed\nlater, for example by a subsequent inline assembly block.\n\nFortunately, the fact that the legacy code generation pipeline does not run the Yul\noptimizer at all on inline assembly blocks that do access Solidity variables,\nreduces the number of affected cases significantly. Most inline assembly blocks either\nread or write values from or to variables defined in the surrounding Solidity code,\nare entirely self-contained, or take over the program flow until the end of\nthe transaction. Thereby, the bug is unlikely to occur in practice and its adverse\neffects should in most cases be easily detectable in tests. However,\nsince the consequences in affected cases can be severe, we assigned it a severity\nof \"medium\".\n\nIn the following example, the legacy code generation pipeline with enabled optimizer will\nremove the `mstore` instruction and the function `f` will return zero:\n\n```solidity\ncontract C {\n    function f() external pure returns (uint256 x) {\n        assembly {\n            mstore(0, 0x42)\n        }\n        assembly {\n            x := mload(0)\n        }\n    }\n}\n```\n\nHowever, if the same memory is either read again in the same inline assembly block\nor if the inline assembly block accesses any local Solidity variables, the bug is\nnot present. Both is the case in the following example, so `f` will return\n`0x42` as expected:\n\n```solidity\ncontract C {\n    function f() external pure returns (uint256 x) {\n        assembly {\n            mstore(0, 0x42)\n            x := mload(0)\n        }\n    }\n}\n```\n\nIn the following example, the first `mstore` will not be removed, since the written memory\nis read again by the `return`. The second `mstore` on the other hand will be removed, since the memory\nit writes is never read again. In this case, this is a valid optimization and the example is not adversely\naffected by the bug. Generally, any assembly block that terminates the transaction or does not have memory side-effects that\nneed to be observed afterwards is unaffected.\n\n```solidity\ncontract C {\n    function f() external {\n        assembly {\n            mstore(0, 0x42)  // This write will be kept, since the return below reads from the memory.\n            mstore(32, 0x21) // This will be removed, but that is valid since the memory is never read again.\n            return(0, 32)\n        }\n    }\n}\n```\n\nThe most dangerous cases affected by the bug are those, in which fixed memory offsets are used to store intermediate\nvalues in one assembly block (e.g. in a helper function), which are then only used in a subsequent assembly block.\n\n```solidity\ncontract C {\n    function callHelper() internal view {\n        assembly {\n            let ret := staticcall(gas(), address(), 0, 0, 0, 0)\n            if eq(ret, 0) {\n                revert(0, 0)\n            }\n            returndatacopy(0, 0, 128) // This will be removed due to the bug.\n        }\n    }\n    function f() external view returns(uint256 x) {\n        callHelper();\n        assembly {\n            // This consumes the memory write by the helper, which was incorrectly removed.\n            x := keccak256(0, 128)\n        }\n    }\n}\n```\n\nHowever, we found it to be uncommon for such patterns to occur: usually, an assembly block either reads from or writes\nto at least one local Solidity variable, consumes the memory it writes directly, or takes over control until the end of\nthe transaction. This is partly due to the fact that using fixed memory offsets for intermediate values between assembly\nblocks is in itself dangerous, since you need to ensure that the Solidity code between the assembly blocks does not overwrite\nthe memory again.\n\nA potentially severely affected pattern would be to reserve static memory at the beginning of the transaction by a write to the\nfree memory pointer (which will be removed due to the bug):\n\n```solidity\ncontract C {\n    // Modifier meant to allow the safe use of 64 bytes of static memory at offset 0x80.\n    modifier reserveStaticMemory() {\n        assembly {\n            // Assert that this is called with the expected initial value of the free memory pointer.\n            if iszero(eq(mload(0x40), 0x80)) { revert(0, 0) }\n            // Reserve 64 bytes of memory between 0x80 and 0xC0.\n            mstore(0x40, 0xC0) // This write will be removed due to the bug.\n        }\n        _;\n    }\n    function someHelper(bytes calldata s) internal pure {\n        bytes32 hash = keccak256(s);\n        assembly {\n            // Store some intermediate values to the supposedly reserved memory.\n            mstore(0x80, 0x12345678)\n            mstore(0xA0, hash)\n        }\n    }\n    function f(bytes calldata s, bytes calldata y) external view reserveStaticMemory returns(uint256 x) {\n        someHelper(s);\n        bytes32 hash = keccak256(y); // Since the free memory pointer was not actually bumped, this will overwrite the memory at 0x80.\n        assembly {\n            x := keccak256(0x80, 0x40) // The memory expected here will have been overwritten.\n            x := xor(x, hash)\n        }\n    }\n}\n```\n","availableURLs":["/2023/05/10/solidity-0.8.20-release-announcement","/2023/03/10/solidity-developer-survey-2022-results","/2023/02/22/user-defined-operators","/2023/02/22/solidity-0.8.19-release-announcement","/2023/02/01/solidity-0.8.18-release-announcement","/2022/12/07/solidity-developer-survey-2022-announcement","/2022/12/05/solidity-core-team-updates","/2022/09/08/storage-write-removal-before-conditional-termination","/2022/09/08/solidity-0.8.17-release-announcement","/2022/08/08/solidity-0.8.16-release-announcement","/2022/08/08/calldata-tuple-reencoding-head-overflow-bug","/2022/06/15/solidity-0.8.15-release-announcement","/2022/06/15/inline-assembly-memory-side-effects-bug","/2022/06/15/dirty-bytes-array-to-storage-bug","/2022/05/17/solidity-0.8.14-release-announcement","/2022/05/17/data-location-inheritance-bug","/2022/05/17/calldata-reencode-size-check-bug","/2022/05/03/solidity-summit-2022-recap","/2022/04/08/announcing-the-underhanded-contest-winners-2022","/2022/03/16/solidity-0.8.13-release-announcement","/2022/03/16/encodecall-bug","/2022/02/22/solidity-summit-2022-announcement","/2022/02/16/solidity-0.8.12-release-announcement","/2022/02/09/underhanded-solidity-contest-2022-announcement","/2022/02/07/solidity-developer-survey-2021-results","/2021/12/20/solidity-0.8.11-release-announcement","/2021/11/18/solidity-developer-survey-2021","/2021/11/09/solidity-0.8.10-release-announcement","/2021/09/29/user-defined-value-types-bug","/2021/09/29/solidity-0.8.9-release-announcement","/2021/09/29/signed-immutables-bug","/2021/09/27/user-defined-value-types","/2021/09/27/solidity-0.8.8-release-announcement","/2021/08/11/solidity-0.8.7-release-announcement","/2021/06/22/solidity-0.8.6-release-announcement","/2021/06/10/solidity-0.8.5-release-announcement","/2021/05/03/soliditylangorg-umbrella-domain","/2021/04/21/solidity-0.8.4-release-announcement","/2021/04/21/decoding-from-memory-bug","/2021/04/21/custom-errors","/2021/04/01/announcing-solidity-collectibles","/2021/03/23/solidity-0.8.3-release-announcement","/2021/03/23/keccak-optimizer-bug","/2021/03/02/solidity-0.8.2-release-announcement","/2021/03/02/saving-gas-with-simple-inliner","/2021/02/15/contributing-to-solidity-101","/2021/02/10/an-introduction-to-soliditys-fuzz-testing-approach","/2021/02/01/launching-the-solidity-forum","/2021/01/27/solidity-0.8.1-release-announcement","/2021/01/26/solidity-developer-survey-2020-results","/2020/12/16/solidity-v0.8.0-release-announcement","/2020/12/16/solidity-0.7.6-release-announcement","/2020/12/09/solidity-developer-survey-2020","/2020/12/03/solidity-underhanded-contest-winners","/2020/11/18/solidity-0.7.5-release-announcement","/2020/11/04/solidity-ama-1-recap","/2020/10/28/solidity-0.8.x-preview","/2020/10/19/solidity-0.7.4-release-announcement","/2020/10/19/empty-byte-array-copy-bug","/2020/10/07/solidity-dynamic-array-cleanup-bug","/2020/10/07/solidity-0.7.3-release-announcement","/2020/09/28/solidity-0.7.2-release-announcement","/2020/09/21/solidity-underhanded-contest","/2020/09/18/meet-the-team","/2020/09/02/solidity-0.7.1-release-announcement","/2020/07/28/solidity-v0.7.0-release-announcement","/2020/07/22/Solidity-0612-release-announcement","/2020/07/08/solidity-turns-5","/2020/07/07/Solidity-0611-release-announcement","/2020/06/25/sourcify-faq","/2020/06/18/solidity-0.6-inheritance","/2020/06/11/Solidity-0610-release-announcement","/2020/06/09/solidity-summit-recap","/2020/06/05/Solidity-069-release-announcement","/2020/06/02/Sourcify-Towards-Safer-Contract-Interaction-for-Humans","/2020/05/26/array-slices","/2020/05/14/Solidity-068-release-announcement","/2020/05/13/immutable-keyword","/2020/05/04/solidity-0.6.7-release-announcement","/2020/04/17/Solidity-Summit-2020-Goes-Interspace","/2020/04/09/solidity-0.6.6-release-announcement","/2020/04/06/solidity-0.6.5-release-announcement","/2020/04/06/memory-creation-overflow-bug","/2020/03/23/fallback-receive-split","/2020/03/17/solidity-0.5.17-release-announcement","/2020/03/10/solidity-0.6.4-release-announcement","/2020/02/18/solidity-0.6.3-release-announcement","/2020/01/29/solidity-0.6-try-catch","/2020/01/27/solidity-0.6.2-release-announcement","/2020/01/02/solidity-0.6.1-release-announcement","/2020/01/02/solidity-0.5.16-release-announcement","/2019/12/17/solidity-0.6.0-release-announcement","/2019/12/17/solidity-0.5.15-release-announcement","/2019/12/09/solidity-0.5.14-release-announcement","/2019/11/14/solidity-0.5.13-release-announcement","/2019/10/01/solidity-0.5.12-release-announcement","/2019/08/12/solidity-0.5.11-release-announcement","/2019/06/25/solidity-storage-array-bugs","/2019/06/25/solidity-0.5.10-release-announcement","/2019/05/28/solidity-0.5.9-release-announcement","/2019/04/30/solidity-0.5.8-release-announcement","/2019/04/29/solidity-0.4.26-release-announcement","/2019/03/26/solidity-optimizer-and-abiencoderv2-bug","/2019/03/26/solidity-0.5.7-release-announcement","/2019/03/13/solidity-0.5.6-release-announcement","/2019/03/05/solidity-0.5.5-release-announcement","/2019/02/12/solidity-0.5.4-release-announcement","/2019/01/22/solidity-0.5.3-release-announcement","/2018/12/19/solidity-0.5.2-release-announcement","/2018/12/03/solidity-0.5.1-release-announcement","/2018/11/13/solidity-0.5.0-release-announcement","/2018/09/13/solidity-bugfix-release","/2018/09/13/solidity-0.4.25-release-announcement","/2018/05/16/solidity-0.4.24-release-announcement","/2018/04/19/solidity-0.4.23-release-announcement","/2018/04/17/solidity-0.4.22-release-announcement","/2018/03/08/solidity-0.4.21-release-announcement","/2018/02/14/solidity-0.4.20-release-announcement","/2017/11/30/solidity-0.4.19-release-announcement","/2017/10/18/solidity-0.4.18-release-announcement","/2017/09/21/solidity-0.4.17-release-announcement","/2017/08/24/solidity-0.4.16-release-announcement","/2017/08/08/solidity-0.4.15-release-announcement","/2017/07/31/solidity-0.4.14-release-announcement","/2017/07/06/solidity-0.4.13-release-announcement","/2017/07/03/solidity-0.4.12-release-announcement","/2017/05/03/solidity-optimizer-bug","/2017/05/03/solidity-0.4.11-release-announcement","/2017/03/15/solidity-0.4.10-release-announcement","/2017/01/31/solidity-0.4.9-release-announcement","/2017/01/13/solidity-0.4.8-release-announcement","/2016/12/15/solidity-0.4.7-release-announcement","/2016/11/22/solidity-0.4.6-release-announcement","/2016/11/21/solidity-0.4.5-release-announcement","/2016/11/09/analysis-storage-corruption-bug","/2016/11/01/solidity-0.4.4-release-announcement","/2016/11/01/security-alert-solidity-variables-can-overwritten-storage","/2016/10/25/solidity-0.4.3-release-announcement","/2016/09/17/solidity-0.4.2-release-announcement","/2016/09/09/solidity-0.4.1-release-announcement","/2016/09/08/solidity-0.4.0-release-announcement","/2016/09/01/formal-methods-roadmap","/2016/08/10/solidity-0.3.6-release-announcement","/2016/06/10/solidity-0.3.5-release-announcement","/2016/06/10/smart-contract-security","/2016/05/31/solidity-0.3.4-release-announcement","/2016/05/27/solidity-0.3.3-release-announcement","/2016/04/18/solidity-0.3.2-release-announcement","/2016/03/31/solidity-0.3.1-release-announcement","/2016/03/11/solidity-0.3.0-release-announcement","/2016/02/17/solidity-0.2.2-release-announcement","/2016/01/30/solidity-0.2.1-release-announcement","/2015/12/01/solidity-0.2.0-release-announcement","/2015/11/17/solidity-0.1.7-release-announcement","/2015/10/16/solidity-0.1.6-release-announcement","/2015/10/07/solidity-0.1.5-release-announcement","/2015/09/30/solidity-0.1.4-release-announcement","/2015/09/22/solidity-0.1.3-release-announcement","/2015/08/21/solidity-0.1.2-release-announcement"]},"__N_SSG":true}