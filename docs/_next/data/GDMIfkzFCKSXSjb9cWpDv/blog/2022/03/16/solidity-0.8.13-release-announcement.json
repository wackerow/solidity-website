{"pageProps":{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.8.13 Release Announcement","date":"2022-03-16","author":"Solidity Team","category":"Releases"},"content":"\n[Solidity v0.8.13](https://github.com/ethereum/solidity/releases/tag/v0.8.13)\nfixes an important bug related to `abi.encodeCall`, extends the `using for`\ndirective and implements \"go to definition\" for the language server.\n\nFurthermore, compiling via the new Yul IR pipeline is now considered production ready.\n\n## Important Bugs\n\nWhen `abi.encodeCall` was introduced in Solidity 0.8.11,\nhex literals (`0x1234`) and string literals (`\"abcd\"`) were not handled properly.\nPlease read more about it in the [security alert](https://blog.soliditylang.org/2022/03/16/encodecall-bug/).\n\n## Notable New Features\n\n### Yul IR Pipeline Production Ready\n\nWe have been working on Yul as an intermediate language for Solidity for several years now.\nYul in itself has been considered production ready for a while - at least since\nABI coder V2 was marked \"stable\", because it makes heavy use of Yul. The other part,\ncode generation from Solidity to Yul, can now also be considered stable and production ready.\n\nIt has been feature complete for several months now. Since the beginning, we always ran all our\ntests through both compiler pipelines. Over the previous weeks, we added several more complex\nreal-world contracts to our testing infrastructure and fixed some minor bugs in the component.\nThe new code generator has been very stable for a long time now. The main reason for not\nmarking it \"non-experimental\" earlier was that it still had problems with limited stack space,\nwhich we were able to fix now.\n\nYou can enable the new pipeline using the `--via-ir` commandline switch or by setting\n`settings.viaIR` to `true` in Standard JSON input (i.e. at the same level where\nyou would have the `optimizer` key).\n\nIt is not recommended to use the Yul compiler pipeline without the optimizer because the unoptimized output\nis primarily meant to be a straightforward transformation of the high-level Solidity code\nand it has many additional checks compared to the old compiler pipeline.\nThis makes it more\nmodular and easier to audit while the new Yul-based optimizer is powerful enough to remove redundancies\nfrom the optimized version. Without the optimizer, you are also more likely to run into \"stack too deep\"\nissues which can often be avoided by the optimizer as explained below.\n\nThe performance of the new pipeline is not yet always superior to the old one, but it\ncan do much higher-level optimization across functions, so please try it out and give us feedback!\n\nFinally, in some edge cases, code compiled via the new compiler pipeline\nbehaves differently than code compiled via the old compiler pipeline.\nThe most prominent is the initialization order of state variables that depend\non the result of constructors in other contracts.\nOthers are related to weird uses of modifiers, dependence of evaluation order inside\nstatements or dirty data. You can find a list of all the changes\nin our [documentation](https://docs.soliditylang.org/en/develop/ir-breaking-changes.html).\n\n### Memory-Safe Assembly / Stack Too Deep\n\nOne important feature of the new compiler pipeline is that the Yul optimizer can move stack variables to memory\nand thus avoid the \"stack too deep\" issue in a lot of cases. In order to do this safely, the compiler\nneeds to know that the memory slots it intends to use are not used by inline assembly.\n\nInline assembly is considered memory-safe if it only uses memory that has been previously allocated\neither by high-level Solidity code or by reading from the free memory pointer at `0x40`.\nAt the very beginning of the code, the compiler sets the free memory pointer to a position\nafter the area reserved for the stack variables that are moved to memory.\n\nThe compiler considers inline assembly blocks as memory safe only for\nvery simple blocks that do not have any opcodes that access memory and also do not access\nSolidity variables related to memory reference types.\nFor all other blocks, it is difficult to impossible to determine this automatically in a safe way\nand thus we added a syntactic mechanism for the developer to assert it:\n\n```solidity\nassembly (\"memory-safe\") { ... }\n```\n\nMarking an unsafe block as memory-safe can lead to undefined behavior\ndue to conflicts between stack variables and memory. The compiler will\nnot check that marked blocks are actually memory safe.\nPlease see the [documentation](https://docs.soliditylang.org/en/v0.8.13/assembly.html#memory-safety)\nfor more information about when an inline assembly block is memory safe.\n\nInline assembly blocks that access memory are not considered memory-safe by default and\neven a single such block disables the stack-to-memory mechanism for the whole contract.\nAssuming otherwise would be dangerous due to the risk of stack variables moved to memory being overwritten.\n\nIf you are e.g. writing a code library that is meant to be used across compiler versions,\nyou can also use a special comment syntax that has the same effect:\n\n```solidity\n/// @solidity memory-safe-assembly\nassembly { ... }\n```\n\nWe advise against using this syntax, though. Please always use the most recent compiler version.\n\n### `using for` at File Level with Global Binding\n\nThis release extends the `using for` directive considerably. It can now be used\nat file level, it is possible to use it with free functions and\nit has the option to make its effect global. We believe that in combination\nwith the recently released user-defined value types, this makes it possible\nto design nicely self-contained types.\n\nIn a future release, we plan to also add operators to user-defined types\nso that things like fixed-point type libraries are really easy to use\nand feel like compiler built-in types.\n\nYou can now use statements like `using {f, g, L.h} for Type;`, where `f`\nand `g` are free functions (defined at file level)\nand `L.h` is a library function.\n\nYou can also add the word `global` at the end to make the effect available\neverywhere. Since the idea is that you are defining a type and\nimplementing the functions of the type, `global` can only be used\nfor a user-defined type and only in the same file where the type is defined.\nWe recommend that the `using` directive is always put directly after the definition\nof the type (forward references are valid in Solidity).\n\nAs an example, let us consider a type that can only be incremented and decremented by one\nat a time. Because of this restriction, we can safely drop overflow checks\nsince it would take more gas than is available in the universe to reach\nan overflow.\n\nFile `\"restrictedNumber.sol\"`:\n\n```solidity\ntype RestrictedNumber is int256;\nusing {plusOne, minusOne} for RestrictedNumber global;\n\nfunction plusOne(RestrictedNumber x) pure returns (RestrictedNumber)\n{\n    unchecked {\n        return RestrictedNumber.wrap(RestrictedNumber.unwrap(x) + 1);\n    }\n}\n\nfunction minusOne(RestrictedNumber x) pure returns (RestrictedNumber)\n{\n    unchecked {\n        return RestrictedNumber.wrap(RestrictedNumber.unwrap(x) - 1);\n    }\n}\n\n/// This is a creation function that ensures that\n/// values are small enough. The idea is that the function\n/// RestrictedNumber.wrap should only be used in the file\n/// that defines the type, so that we have control over\n/// the invariants.\nfunction createRestrictedNumber(int256 value) pure returns (RestrictedNumber)\n{\n    // Ensure that the number is \"small\".\n    // Larger constants like 2**200 would also work.\n    require(value <= 100 && -value <= 100);\n    return RestrictedNumber.wrap(value);\n}\n```\n\nFile `\"owned.sol\"`:\n\n```solidity\nimport {RestrictedNumber} from \"./restrictedNumber.sol\";\n\ncontract Owned {\n    RestrictedNumber public ownerCount;\n    mapping(address => bool) public isOwner;\n\n    constructor() {\n        _addOwner(msg.sender);\n    }\n\n    function addOwner(address owner) external {\n        require(isOwner[msg.sender]);\n        _addOwner(owner);\n    }\n\n    function removeOwner(address owner) external {\n        require(isOwner[msg.sender]);\n        require(isOwner[owner]);\n        // Because of `global`, we do not have to add\n        // `using for` in the contract to use the\n        // ``minusOne`` function.\n        ownerCount = ownerCount.minusOne();\n        isOwner[owner] = false;\n    }\n\n    function _addOwner(address owner) internal {\n        require(!isOwner[owner]);\n        ownerCount = ownerCount.plusOne();\n        isOwner[owner] = true;\n    }\n}\n```\n\n### \"Go to Definition\" for LSP\n\nThe Solidity Language Server has been further improved and received\none new feature: definition lookup of the underlying symbol.\n\nThis works on every symbol, such as local variables, return variables,\ntype names, but also on import statements.\n\nWe consider the official Solidity Language Server still as a preview,\nthat is, while it is already functional, there will be much more coming.\n\nPlease test it out and leave us some\n[feedback](https://github.com/ethereum/solidity/issues/new?template=feature_request.md&labels=language%20server)\nin our GitHub issue tracker.\n\n## Full Changelog\n\n**Important Bugfixes:**\n\n- Code Generator: Correctly encode literals used in `abi.encodeCall` in place of fixed bytes arguments.\n\n**Language Features:**\n\n- General: Allow annotating inline assembly as memory-safe to allow optimizations and stack limit evasion that rely on respecting Solidity's memory model.\n- General: `using M for Type;` is allowed at file level and `M` can now also be a brace-enclosed list of free functions or library functions.\n- General: `using ... for T global;` is allowed at file level where the user-defined type `T` has been defined, resulting in the effect of the statement being available everywhere `T` is available.\n\n**Compiler Features:**\n\n- Commandline Interface: Allow the use of `--via-ir` in place of `--experimental-via-ir`.\n- Compilation via Yul IR is no longer marked as experimental.\n- JSON-AST: Added selector field for errors and events.\n- LSP: Implements goto-definition.\n- Peephole Optimizer: Optimize comparisons in front of conditional jumps and conditional jumps across a single unconditional jump.\n- Yul EVM Code Transform: Avoid unnecessary `pop`s on terminating control flow.\n- Yul Optimizer: Remove `sstore` and `mstore` operations that are never read from.\n\n**Bugfixes:**\n\n- General: Fix internal error for locales with unusual capitalization rules. Locale set in the environment is now completely ignored.\n- Type Checker: Fix incorrect type checker errors when importing overloaded functions.\n- Yul IR Code Generation: Optimize embedded creation code with correct settings. This fixes potential mismatches between the constructor code of a contract compiled in isolation and the bytecode in `type(C).creationCode`, resp. the bytecode used for `new C(...)`.\n\nA big thank you to all contributors who helped make this release possible!\n\nDownload the new version of Solidity [here](https://github.com/ethereum/solidity/releases/tag/v0.8.13).\n","availableURLs":["/2023/05/10/solidity-0.8.20-release-announcement","/2023/03/10/solidity-developer-survey-2022-results","/2023/02/22/user-defined-operators","/2023/02/22/solidity-0.8.19-release-announcement","/2023/02/01/solidity-0.8.18-release-announcement","/2022/12/07/solidity-developer-survey-2022-announcement","/2022/12/05/solidity-core-team-updates","/2022/09/08/storage-write-removal-before-conditional-termination","/2022/09/08/solidity-0.8.17-release-announcement","/2022/08/08/solidity-0.8.16-release-announcement","/2022/08/08/calldata-tuple-reencoding-head-overflow-bug","/2022/06/15/solidity-0.8.15-release-announcement","/2022/06/15/inline-assembly-memory-side-effects-bug","/2022/06/15/dirty-bytes-array-to-storage-bug","/2022/05/17/solidity-0.8.14-release-announcement","/2022/05/17/data-location-inheritance-bug","/2022/05/17/calldata-reencode-size-check-bug","/2022/05/03/solidity-summit-2022-recap","/2022/04/08/announcing-the-underhanded-contest-winners-2022","/2022/03/16/solidity-0.8.13-release-announcement","/2022/03/16/encodecall-bug","/2022/02/22/solidity-summit-2022-announcement","/2022/02/16/solidity-0.8.12-release-announcement","/2022/02/09/underhanded-solidity-contest-2022-announcement","/2022/02/07/solidity-developer-survey-2021-results","/2021/12/20/solidity-0.8.11-release-announcement","/2021/11/18/solidity-developer-survey-2021","/2021/11/09/solidity-0.8.10-release-announcement","/2021/09/29/user-defined-value-types-bug","/2021/09/29/solidity-0.8.9-release-announcement","/2021/09/29/signed-immutables-bug","/2021/09/27/user-defined-value-types","/2021/09/27/solidity-0.8.8-release-announcement","/2021/08/11/solidity-0.8.7-release-announcement","/2021/06/22/solidity-0.8.6-release-announcement","/2021/06/10/solidity-0.8.5-release-announcement","/2021/05/03/soliditylangorg-umbrella-domain","/2021/04/21/solidity-0.8.4-release-announcement","/2021/04/21/decoding-from-memory-bug","/2021/04/21/custom-errors","/2021/04/01/announcing-solidity-collectibles","/2021/03/23/solidity-0.8.3-release-announcement","/2021/03/23/keccak-optimizer-bug","/2021/03/02/solidity-0.8.2-release-announcement","/2021/03/02/saving-gas-with-simple-inliner","/2021/02/15/contributing-to-solidity-101","/2021/02/10/an-introduction-to-soliditys-fuzz-testing-approach","/2021/02/01/launching-the-solidity-forum","/2021/01/27/solidity-0.8.1-release-announcement","/2021/01/26/solidity-developer-survey-2020-results","/2020/12/16/solidity-v0.8.0-release-announcement","/2020/12/16/solidity-0.7.6-release-announcement","/2020/12/09/solidity-developer-survey-2020","/2020/12/03/solidity-underhanded-contest-winners","/2020/11/18/solidity-0.7.5-release-announcement","/2020/11/04/solidity-ama-1-recap","/2020/10/28/solidity-0.8.x-preview","/2020/10/19/solidity-0.7.4-release-announcement","/2020/10/19/empty-byte-array-copy-bug","/2020/10/07/solidity-dynamic-array-cleanup-bug","/2020/10/07/solidity-0.7.3-release-announcement","/2020/09/28/solidity-0.7.2-release-announcement","/2020/09/21/solidity-underhanded-contest","/2020/09/18/meet-the-team","/2020/09/02/solidity-0.7.1-release-announcement","/2020/07/28/solidity-v0.7.0-release-announcement","/2020/07/22/Solidity-0612-release-announcement","/2020/07/08/solidity-turns-5","/2020/07/07/Solidity-0611-release-announcement","/2020/06/25/sourcify-faq","/2020/06/18/solidity-0.6-inheritance","/2020/06/11/Solidity-0610-release-announcement","/2020/06/09/solidity-summit-recap","/2020/06/05/Solidity-069-release-announcement","/2020/06/02/Sourcify-Towards-Safer-Contract-Interaction-for-Humans","/2020/05/26/array-slices","/2020/05/14/Solidity-068-release-announcement","/2020/05/13/immutable-keyword","/2020/05/04/solidity-0.6.7-release-announcement","/2020/04/17/Solidity-Summit-2020-Goes-Interspace","/2020/04/09/solidity-0.6.6-release-announcement","/2020/04/06/solidity-0.6.5-release-announcement","/2020/04/06/memory-creation-overflow-bug","/2020/03/23/fallback-receive-split","/2020/03/17/solidity-0.5.17-release-announcement","/2020/03/10/solidity-0.6.4-release-announcement","/2020/02/18/solidity-0.6.3-release-announcement","/2020/01/29/solidity-0.6-try-catch","/2020/01/27/solidity-0.6.2-release-announcement","/2020/01/02/solidity-0.6.1-release-announcement","/2020/01/02/solidity-0.5.16-release-announcement","/2019/12/17/solidity-0.6.0-release-announcement","/2019/12/17/solidity-0.5.15-release-announcement","/2019/12/09/solidity-0.5.14-release-announcement","/2019/11/14/solidity-0.5.13-release-announcement","/2019/10/01/solidity-0.5.12-release-announcement","/2019/08/12/solidity-0.5.11-release-announcement","/2019/06/25/solidity-storage-array-bugs","/2019/06/25/solidity-0.5.10-release-announcement","/2019/05/28/solidity-0.5.9-release-announcement","/2019/04/30/solidity-0.5.8-release-announcement","/2019/04/29/solidity-0.4.26-release-announcement","/2019/03/26/solidity-optimizer-and-abiencoderv2-bug","/2019/03/26/solidity-0.5.7-release-announcement","/2019/03/13/solidity-0.5.6-release-announcement","/2019/03/05/solidity-0.5.5-release-announcement","/2019/02/12/solidity-0.5.4-release-announcement","/2019/01/22/solidity-0.5.3-release-announcement","/2018/12/19/solidity-0.5.2-release-announcement","/2018/12/03/solidity-0.5.1-release-announcement","/2018/11/13/solidity-0.5.0-release-announcement","/2018/09/13/solidity-bugfix-release","/2018/09/13/solidity-0.4.25-release-announcement","/2018/05/16/solidity-0.4.24-release-announcement","/2018/04/19/solidity-0.4.23-release-announcement","/2018/04/17/solidity-0.4.22-release-announcement","/2018/03/08/solidity-0.4.21-release-announcement","/2018/02/14/solidity-0.4.20-release-announcement","/2017/11/30/solidity-0.4.19-release-announcement","/2017/10/18/solidity-0.4.18-release-announcement","/2017/09/21/solidity-0.4.17-release-announcement","/2017/08/24/solidity-0.4.16-release-announcement","/2017/08/08/solidity-0.4.15-release-announcement","/2017/07/31/solidity-0.4.14-release-announcement","/2017/07/06/solidity-0.4.13-release-announcement","/2017/07/03/solidity-0.4.12-release-announcement","/2017/05/03/solidity-optimizer-bug","/2017/05/03/solidity-0.4.11-release-announcement","/2017/03/15/solidity-0.4.10-release-announcement","/2017/01/31/solidity-0.4.9-release-announcement","/2017/01/13/solidity-0.4.8-release-announcement","/2016/12/15/solidity-0.4.7-release-announcement","/2016/11/22/solidity-0.4.6-release-announcement","/2016/11/21/solidity-0.4.5-release-announcement","/2016/11/09/analysis-storage-corruption-bug","/2016/11/01/solidity-0.4.4-release-announcement","/2016/11/01/security-alert-solidity-variables-can-overwritten-storage","/2016/10/25/solidity-0.4.3-release-announcement","/2016/09/17/solidity-0.4.2-release-announcement","/2016/09/09/solidity-0.4.1-release-announcement","/2016/09/08/solidity-0.4.0-release-announcement","/2016/09/01/formal-methods-roadmap","/2016/08/10/solidity-0.3.6-release-announcement","/2016/06/10/solidity-0.3.5-release-announcement","/2016/06/10/smart-contract-security","/2016/05/31/solidity-0.3.4-release-announcement","/2016/05/27/solidity-0.3.3-release-announcement","/2016/04/18/solidity-0.3.2-release-announcement","/2016/03/31/solidity-0.3.1-release-announcement","/2016/03/11/solidity-0.3.0-release-announcement","/2016/02/17/solidity-0.2.2-release-announcement","/2016/01/30/solidity-0.2.1-release-announcement","/2015/12/01/solidity-0.2.0-release-announcement","/2015/11/17/solidity-0.1.7-release-announcement","/2015/10/16/solidity-0.1.6-release-announcement","/2015/10/07/solidity-0.1.5-release-announcement","/2015/09/30/solidity-0.1.4-release-announcement","/2015/09/22/solidity-0.1.3-release-announcement","/2015/08/21/solidity-0.1.2-release-announcement"]},"__N_SSG":true}