{"pageProps":{"frontmatter":{"layout":"post","published":true,"title":"Head Overflow Bug in Calldata Tuple ABI-Reencoding","date":"2022-08-08","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn July 5, 2022, Chance Hudson ([@vimwitch](https://github.com/vimwitch)) from the Ethereum Foundation discovered a bug in the Solidity code generator.\n\nThe earliest affected version of the compiler is 0.5.8, which introduced ABI-reencoding of calldata arrays and structs.\n[Solidity version 0.8.16](https://github.com/ethereum/solidity/releases/tag/v0.8.16), released on August 08, 2022, provides a fix.\n\nWe assigned the bug a severity of \"medium\".\n\n## Which Contracts are Affected?\n\nThe effects of the bug manifest when a contract performs ABI-encoding of a tuple that meets **all** of the following conditions:\n\n1. The last component of the tuple is a (potentially nested) statically-sized calldata array with the most base type being either `uint` or `bytes32`.\n   E.g. `bytes32[10]` or `uint[2][2][2]`.\n2. The tuple contains at least one dynamic component.\n   E.g. `bytes` or a struct containing a dynamic array.\n3. The code is using ABI coder v2, which is the default since Solidity 0.8.0.\n\nNote that structs are represented as tuples in the ABI.\nParameter and return value lists of external functions, events and errors are also implicitly treated as tuples.\n\nThe bug can be triggered by explicit use of the `abi.encode...` family of functions as well as the ABI-encoding performed\nimplicitly for external functions, events and errors by the compiler.\n\nThe bug is independent of the use of the optimizer and affects both the legacy and the IR-based compilation pipelines.\n\n## Technical Details\n\nThe bug is the result of overly eager cleanup performed by the compiler when copying calldata arrays to memory during ABI-encoding.\nArrays in memory always occupy a multiple of 32 bytes and when the base type does not fill the whole word,\nthe unused space is guaranteed to be zeroed and remain clean after all high-level Solidity operations.\nIn the affected cases the compiler would emit code that incorrectly cleaned the end of an array stored in the last component of a tuple,\nzeroing 32 bytes belonging to the first dynamic component of the tuple.\n\n### Aggressive Array Cleanup\n\nWhen the input for the ABI encoder comes from calldata, large parts of it can simply be copied to the output.\nThe encoder, however, must ensure that the unused spaces between elements are actually\n[cleaned](https://docs.soliditylang.org/en/latest/internals/variable_cleanup.html).\n\nDepending on the types, more or less work may be needed and the encoder has several code paths for handling them.\nOne of them was designed for (possibly multi-dimensional) arrays of simple value types that fill the whole word,\ni.e. `uint` and `bytes32`, as well as byte arrays, i.e. `bytes` and `string`.\nIn this case, due to tight packing of array elements, only the area past the array may need cleanup and that\narea is never larger than 32 bytes.\n\nThe cleanup was being performed using a single `mstore()` instruction, which always writes exactly 32 bytes.\nThis was not considered harmful because of the order in which the encoder writes tuple components.\nThe space after any given tuple component was assumed to be safe to write because it would eventually be\noverwritten with the data belonging to the next component.\n\nThe cleanup is necessary only in the byte array case, but due to the shared code path was also being\nperformed for `uint` and `bytes32`.\nThis is completely redundant, but was overlooked in the initial implementation and not discovered\nuntil now, likely because it does not produce clearly visible side-effects in simple cases.\nThe redundant instruction may even be removed by the optimizer in newer versions of the compiler.\n\nIn order to explain why the assumption turned out to be incorrect, let us take a closer look at\nthe layout of an ABI-encoded tuple.\n\n### Layout and Encoding Order of Static and Dynamic Tuples\n\n[The ABI encoding of a tuple](https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding)\nconsists of two areas - the statically encoded _head_ and the dynamically encoded _tail_.\nEvery static component is placed directly in the head area while for dynamic ones, the head contains only the offset\nof the location within the tail where the data is stored.\nThis layout ensures that component locations within the head are fixed and any of them can be accessed without the need to decode all\nthe components that precede it.\n\n#### Static Encoding Example\n\nLet us consider the following example that encodes a tuple with no dynamic components:\n\n```solidity\nstruct S {\n    address x;\n    uint[3] y;\n}\n\ncontract C {\n    function f(bool a, S calldata b, bytes32[2] calldata c) public {}\n}\n```\n\nAn example call to `C.f()` with the following input:\n\n```solidity\nf(true, S(0x1111111111222222222233333333334444444444, [uint(11), 12, 13]), [bytes32(\"a\"), \"b\"])\n```\n\nwould encode its arguments as follows:\n\n```\n0x0000000000000000000000000000000000000000000000000000000000000001 a\n0x0000000000000000000000001111111111222222222233333333334444444444 b.x\n0x000000000000000000000000000000000000000000000000000000000000000b b.y[0]\n0x000000000000000000000000000000000000000000000000000000000000000c b.y[1]\n0x000000000000000000000000000000000000000000000000000000000000000d b.y[2]\n0x6100000000000000000000000000000000000000000000000000000000000000 c[0]\n0x6200000000000000000000000000000000000000000000000000000000000000 c[1]\n```\n\nThe encoded tuple has no tail and is laid out in the following way:\n\n```\n|---------------------------------------------------|\n|                        HEAD                       |\n|------------+-------------------------+------------|\n| value of a |        value of b       | value of c |\n|    bool    |             S           | bytes32[2] |\n|            |-------------------------|            |\n|            |          HEAD of S      |            |\n|            |------------+------------|            |\n|            | value of x | value of y |            |\n|            |   address  |   uint[3]  |            |\n|------------+------------+------------+------------|\n|     1      |      2     |     3      |      4     |\n|------------+------------+------------+------------|\n```\n\nThe numbers at the bottom indicate the order in which the components are written by the encoder.\n\n#### Dynamic Encoding Example\n\nThe example below uses a very similar tuple but with one of the static fields replaced by a dynamic one:\n\n```solidity\nstruct T {\n    bytes x;\n    uint[3] y;\n}\n\ncontract D {\n    function f(bool a, T calldata b, bytes32[2] calldata c) public { }\n}\n```\n\nIn this case a call to `D.f()` with the following input:\n\n```solidity\nf(true, T(\"abcd\", [uint(11), 12, 13]), [bytes32(\"a\"), \"b\"])\n```\n\nresults in a vastly different encoding:\n\n```\n0x0000000000000000000000000000000000000000000000000000000000000001 a\n0x0000000000000000000000000000000000000000000000000000000000000080 offset of b\n0x6100000000000000000000000000000000000000000000000000000000000000 c[0]\n0x6200000000000000000000000000000000000000000000000000000000000000 c[1]\n0x0000000000000000000000000000000000000000000000000000000000000080 offset of b.x\n0x000000000000000000000000000000000000000000000000000000000000000b b.y[0]\n0x000000000000000000000000000000000000000000000000000000000000000c b.y[1]\n0x000000000000000000000000000000000000000000000000000000000000000d b.y[2]\n0x0000000000000000000000000000000000000000000000000000000000000004 b.x (length field)\n0x6162636400000000000000000000000000000000000000000000000000000000 b.x (data)\n```\n\nThe introduction of a dynamic type resulted in `T` itself becoming a dynamic type as well.\nThe new encoding has two tail areas, at different nesting levels:\n\n```\n|---------------------------------------||----------------------------------------|\n|                  HEAD                 ||                 TAIL                   |\n|------------+-------------+------------||----------------------------------------|\n| value of a | offset of b | value of c ||              value of b                |\n|    bool    |    uint     | bytes32[2] ||                   T                    |\n|            |             |            ||--------------------------||------------|\n|            |             |            ||          HEAD of T       || TAIL of T  |\n|            |             |            ||-------------+------------||------------|\n|            |             |            || offset of x | value of y || value of x |\n|            |             |            ||    uint     |   uint[3]  ||    bytes   |\n|------------+-------------+------------||-------------+------------||------------|\n|     1      |      2      |      6     ||      3      |     5      ||      4     |\n|------------+-------------+------------||-------------+------------||------------|\n```\n\nThe encoding order was also affected.\nThis is because for each component, the encoder writes both the head and the tail before moving on to the next one.\nThis results in `c` being written after `b.x`, even though the former precedes the latter in the encoding.\nA similar situation happens inside `T` - when `y` is being written the data belonging to the tail of `x` is already in place.\n\n## Effects of the Bug\n\nThe aggressive cleanup combined with the non-linear encoding order of dynamic types resulted in a bug where\nthe initial 32 bytes of the tail could be overwritten during the cleanup of the last head component.\n\nThe dynamic tuple example above meets all the criteria for the bug so introducing ABI reencoding would trigger it:\n\n```solidity\nstruct T {\n    bytes x;\n    uint[3] y;\n}\n\ncontract E {\n    function f(bool a, T calldata b, bytes32[2] calldata c)\n        public\n        returns (bool, T calldata, bytes32[2] calldata)\n    {\n        return (a, b, c);\n    }\n}\n```\n\nEven though `E.f()` is meant to simply return the same input it receives, due to the bug it would produce faulty encoding:\n\n```\n0x0000000000000000000000000000000000000000000000000000000000000001 a\n0x0000000000000000000000000000000000000000000000000000000000000080 offset of b\n0x6100000000000000000000000000000000000000000000000000000000000000 c[0]\n0x6200000000000000000000000000000000000000000000000000000000000000 c[1]\n0x0000000000000000000000000000000000000000000000000000000000000000 offset of b.x      // Wrong value\n0x000000000000000000000000000000000000000000000000000000000000000b b.y[0]\n0x000000000000000000000000000000000000000000000000000000000000000c b.y[1]\n0x000000000000000000000000000000000000000000000000000000000000000d b.y[2]\n0x0000000000000000000000000000000000000000000000000000000000000000 b.x (length field) // Wrong value\n0x6162636400000000000000000000000000000000000000000000000000000000 b.x (data)\n```\n\nHere, the cleanup performed for `b.y` would overwrite the length field of `b.x`.\nSimilarly, the cleanup of `c` would overwrite the offset of `b.x`.\n\nNote that the above is not the most minimal example that reproduces the bug.\nTo better illustrate the consequences, this case has two nested tuples and the overwrite happens twice\nbut it is possible to reproduce it even with a single tuple with two components.\n\nThe case with a static tuple was not affected because, in absence of the tail, the encoding order is linear.\nThe encoder could still write past the end of the whole area reserved for the encoding but the compiler would be able\nto ensure that the memory past it had not been allocated for another purpose, making the cleanup perfectly safe.\n\nThe bug only affected the encoding of tuples in the presence of a `calldata` array because that was the only situation where\nthe routine that performs the aggressive cleanup was used.\n\nThe routine is a part of the IR-based code generator and runs regardless of the use of the optimizer,\nwhich means that both optimized and unoptimized code is affected.\n\nSince the legacy code generation pipeline does not have its own ABI coder v2 implementation and uses\nthe IR-based generator for ABI encoding, the bug can be triggered when using either pipeline.\nIt does not, however, affect ABI coder v1.\n\n## Impact\n\nThe bug is very easy to trigger in contrived situations but requires a combination of multiple factors to manifest.\nThis seems to lower the likelihood of it being triggered, given that it remained undetected through several major releases.\nIt may, however, have gone unnoticed in the encoded data of events or errors.\n\nIntentionally triggering the bug when calling a function is not exploitable because the caller can always just directly pass\nmodified input to the function being called.\nPlausible attacks against affected contracts can only occur in situations where the contract accepts a static calldata\narray as a part of its input and forwards it to another external call without modifying the content.\n\nOne of the scenarios that make the bug more likely is batching of orders:\n\n```solidity\nstruct Order {\n    User buyer;\n    User seller;\n    uint[2] values;\n}\n\nstruct User {\n    address account;\n    string name;\n}\n\ncontract Batcher {\n    IMarket immutable market;\n\n    function batchTransaction(Order[] calldata orders) external {\n        for (uint i = 0; i < orders.length; ++i) {\n            // batchTransaction() can see the original value of buyer.account and act on it.\n            // The check here will not fail unless the caller actually sets the address to zero.\n            require(orders[i].buyer.account != address(0));\n\n            // Inside transact() buyer.account always becomes zero due to the bug.\n            market.transact(orders[i].buyer, orders[i].seller, orders[i].values);\n        }\n    }\n}\n\ninterface IMarket {\n    function transact(User memory, User memory, uint[2] memory) external;\n}\n```\n","availableURLs":["/2023/05/10/solidity-0.8.20-release-announcement","/2023/03/10/solidity-developer-survey-2022-results","/2023/02/22/user-defined-operators","/2023/02/22/solidity-0.8.19-release-announcement","/2023/02/01/solidity-0.8.18-release-announcement","/2022/12/07/solidity-developer-survey-2022-announcement","/2022/12/05/solidity-core-team-updates","/2022/09/08/storage-write-removal-before-conditional-termination","/2022/09/08/solidity-0.8.17-release-announcement","/2022/08/08/solidity-0.8.16-release-announcement","/2022/08/08/calldata-tuple-reencoding-head-overflow-bug","/2022/06/15/solidity-0.8.15-release-announcement","/2022/06/15/inline-assembly-memory-side-effects-bug","/2022/06/15/dirty-bytes-array-to-storage-bug","/2022/05/17/solidity-0.8.14-release-announcement","/2022/05/17/data-location-inheritance-bug","/2022/05/17/calldata-reencode-size-check-bug","/2022/05/03/solidity-summit-2022-recap","/2022/04/08/announcing-the-underhanded-contest-winners-2022","/2022/03/16/solidity-0.8.13-release-announcement","/2022/03/16/encodecall-bug","/2022/02/22/solidity-summit-2022-announcement","/2022/02/16/solidity-0.8.12-release-announcement","/2022/02/09/underhanded-solidity-contest-2022-announcement","/2022/02/07/solidity-developer-survey-2021-results","/2021/12/20/solidity-0.8.11-release-announcement","/2021/11/18/solidity-developer-survey-2021","/2021/11/09/solidity-0.8.10-release-announcement","/2021/09/29/user-defined-value-types-bug","/2021/09/29/solidity-0.8.9-release-announcement","/2021/09/29/signed-immutables-bug","/2021/09/27/user-defined-value-types","/2021/09/27/solidity-0.8.8-release-announcement","/2021/08/11/solidity-0.8.7-release-announcement","/2021/06/22/solidity-0.8.6-release-announcement","/2021/06/10/solidity-0.8.5-release-announcement","/2021/05/03/soliditylangorg-umbrella-domain","/2021/04/21/solidity-0.8.4-release-announcement","/2021/04/21/decoding-from-memory-bug","/2021/04/21/custom-errors","/2021/04/01/announcing-solidity-collectibles","/2021/03/23/solidity-0.8.3-release-announcement","/2021/03/23/keccak-optimizer-bug","/2021/03/02/solidity-0.8.2-release-announcement","/2021/03/02/saving-gas-with-simple-inliner","/2021/02/15/contributing-to-solidity-101","/2021/02/10/an-introduction-to-soliditys-fuzz-testing-approach","/2021/02/01/launching-the-solidity-forum","/2021/01/27/solidity-0.8.1-release-announcement","/2021/01/26/solidity-developer-survey-2020-results","/2020/12/16/solidity-v0.8.0-release-announcement","/2020/12/16/solidity-0.7.6-release-announcement","/2020/12/09/solidity-developer-survey-2020","/2020/12/03/solidity-underhanded-contest-winners","/2020/11/18/solidity-0.7.5-release-announcement","/2020/11/04/solidity-ama-1-recap","/2020/10/28/solidity-0.8.x-preview","/2020/10/19/solidity-0.7.4-release-announcement","/2020/10/19/empty-byte-array-copy-bug","/2020/10/07/solidity-dynamic-array-cleanup-bug","/2020/10/07/solidity-0.7.3-release-announcement","/2020/09/28/solidity-0.7.2-release-announcement","/2020/09/21/solidity-underhanded-contest","/2020/09/18/meet-the-team","/2020/09/02/solidity-0.7.1-release-announcement","/2020/07/28/solidity-v0.7.0-release-announcement","/2020/07/22/Solidity-0612-release-announcement","/2020/07/08/solidity-turns-5","/2020/07/07/Solidity-0611-release-announcement","/2020/06/25/sourcify-faq","/2020/06/18/solidity-0.6-inheritance","/2020/06/11/Solidity-0610-release-announcement","/2020/06/09/solidity-summit-recap","/2020/06/05/Solidity-069-release-announcement","/2020/06/02/Sourcify-Towards-Safer-Contract-Interaction-for-Humans","/2020/05/26/array-slices","/2020/05/14/Solidity-068-release-announcement","/2020/05/13/immutable-keyword","/2020/05/04/solidity-0.6.7-release-announcement","/2020/04/17/Solidity-Summit-2020-Goes-Interspace","/2020/04/09/solidity-0.6.6-release-announcement","/2020/04/06/solidity-0.6.5-release-announcement","/2020/04/06/memory-creation-overflow-bug","/2020/03/23/fallback-receive-split","/2020/03/17/solidity-0.5.17-release-announcement","/2020/03/10/solidity-0.6.4-release-announcement","/2020/02/18/solidity-0.6.3-release-announcement","/2020/01/29/solidity-0.6-try-catch","/2020/01/27/solidity-0.6.2-release-announcement","/2020/01/02/solidity-0.6.1-release-announcement","/2020/01/02/solidity-0.5.16-release-announcement","/2019/12/17/solidity-0.6.0-release-announcement","/2019/12/17/solidity-0.5.15-release-announcement","/2019/12/09/solidity-0.5.14-release-announcement","/2019/11/14/solidity-0.5.13-release-announcement","/2019/10/01/solidity-0.5.12-release-announcement","/2019/08/12/solidity-0.5.11-release-announcement","/2019/06/25/solidity-storage-array-bugs","/2019/06/25/solidity-0.5.10-release-announcement","/2019/05/28/solidity-0.5.9-release-announcement","/2019/04/30/solidity-0.5.8-release-announcement","/2019/04/29/solidity-0.4.26-release-announcement","/2019/03/26/solidity-optimizer-and-abiencoderv2-bug","/2019/03/26/solidity-0.5.7-release-announcement","/2019/03/13/solidity-0.5.6-release-announcement","/2019/03/05/solidity-0.5.5-release-announcement","/2019/02/12/solidity-0.5.4-release-announcement","/2019/01/22/solidity-0.5.3-release-announcement","/2018/12/19/solidity-0.5.2-release-announcement","/2018/12/03/solidity-0.5.1-release-announcement","/2018/11/13/solidity-0.5.0-release-announcement","/2018/09/13/solidity-bugfix-release","/2018/09/13/solidity-0.4.25-release-announcement","/2018/05/16/solidity-0.4.24-release-announcement","/2018/04/19/solidity-0.4.23-release-announcement","/2018/04/17/solidity-0.4.22-release-announcement","/2018/03/08/solidity-0.4.21-release-announcement","/2018/02/14/solidity-0.4.20-release-announcement","/2017/11/30/solidity-0.4.19-release-announcement","/2017/10/18/solidity-0.4.18-release-announcement","/2017/09/21/solidity-0.4.17-release-announcement","/2017/08/24/solidity-0.4.16-release-announcement","/2017/08/08/solidity-0.4.15-release-announcement","/2017/07/31/solidity-0.4.14-release-announcement","/2017/07/06/solidity-0.4.13-release-announcement","/2017/07/03/solidity-0.4.12-release-announcement","/2017/05/03/solidity-optimizer-bug","/2017/05/03/solidity-0.4.11-release-announcement","/2017/03/15/solidity-0.4.10-release-announcement","/2017/01/31/solidity-0.4.9-release-announcement","/2017/01/13/solidity-0.4.8-release-announcement","/2016/12/15/solidity-0.4.7-release-announcement","/2016/11/22/solidity-0.4.6-release-announcement","/2016/11/21/solidity-0.4.5-release-announcement","/2016/11/09/analysis-storage-corruption-bug","/2016/11/01/solidity-0.4.4-release-announcement","/2016/11/01/security-alert-solidity-variables-can-overwritten-storage","/2016/10/25/solidity-0.4.3-release-announcement","/2016/09/17/solidity-0.4.2-release-announcement","/2016/09/09/solidity-0.4.1-release-announcement","/2016/09/08/solidity-0.4.0-release-announcement","/2016/09/01/formal-methods-roadmap","/2016/08/10/solidity-0.3.6-release-announcement","/2016/06/10/solidity-0.3.5-release-announcement","/2016/06/10/smart-contract-security","/2016/05/31/solidity-0.3.4-release-announcement","/2016/05/27/solidity-0.3.3-release-announcement","/2016/04/18/solidity-0.3.2-release-announcement","/2016/03/31/solidity-0.3.1-release-announcement","/2016/03/11/solidity-0.3.0-release-announcement","/2016/02/17/solidity-0.2.2-release-announcement","/2016/01/30/solidity-0.2.1-release-announcement","/2015/12/01/solidity-0.2.0-release-announcement","/2015/11/17/solidity-0.1.7-release-announcement","/2015/10/16/solidity-0.1.6-release-announcement","/2015/10/07/solidity-0.1.5-release-announcement","/2015/09/30/solidity-0.1.4-release-announcement","/2015/09/22/solidity-0.1.3-release-announcement","/2015/08/21/solidity-0.1.2-release-announcement"]},"__N_SSG":true}