{"pageProps":{"frontmatter":{"layout":"post","published":true,"title":"Storage Write Removal Bug On Conditional Early Termination","date":"2022-09-08","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn September 5, 2022, a bug in Solidity's Yul optimizer was found by differential fuzzing.\n\nThe bug was introduced in version 0.8.13 and [Solidity version 0.8.17](https://github.com/ethereum/solidity/releases/tag/v0.8.17), released on September 08, 2022, provides a fix. The bug is significantly easier to trigger with optimized via-IR code generation, but can theoretically also occur in optimized legacy code generation.\n\nWe assigned the bug a severity of \"medium/high\".\n\n## Who Should Be Concerned\n\nIf you're using optimized legacy code generation, you only need to be concerned, if you use large inline assembly blocks that contain user-defined assembly functions that involve the `return(...)` or `stop()` instructions. Furthermore only inline assembly blocks that do not interact with any surrounding Solidity variables can be affected.\n\nIf you're using optimized via-IR code generation, you are more likely to be affected.\n\nYou should carefully check your contract whenever it involves any code path that first writes to storage and then continues to an early termination using assembly `return(...)` or `stop()`, but can also conditionally bypass this early termination. This includes cases in which the storage writes or the early termination occur in complex control flow or in arbitrarily nested function calls.\n\n## Which Contracts are Affected?\n\nA prerequisite for a contract to be affected is the use of `return(...)` or `stop()` in an inline assembly block (note that `return(...)` here refers to the builtin inline assembly function, not to the `return` statement of Solidity). Such an inline assembly call will not return from the current function, but instead result in an early successful (i.e. non-reverting) termination of the entire external EVM call.\n\nIf your contract doesn't contain any inline assembly block with `return(...)` or `stop()` statements, you're unaffected.\n\nIf it does and this early termination happens conditionally within a function, the optimizer could incorrectly remove storage writes before calls to the function.\n\nMore concretely, the bug can occur if a contract contains the following pattern:\n\n1. A storage write. Note that the write may still be removed even if it happens only conditionally or within a call to a function that ends up being inlined.\n2. A call to a function that conditionally terminates using inline assembly as described above, but also has a different code path that returns to the caller.\n3. Any continuing control flow path does one of the following:\n   - It overwrites the storage write in (1).\n   - It reverts.\n\nIf the initial storage write could possibly be read back (directly or in any internal or external call) between (1) and (3), it is, of course, never removed. Note, however, that in presence of the optimizer it is not always easy to determine if a storage read at the Solidity level will actually translate to a load instruction in assembly. For example the [Load Resolver](https://docs.soliditylang.org/en/latest/internals/optimizer.html#load-resolver) step can use the knowledge of values that were written before by the contract to replace a `sload()` directly with the value that it would read.\n\nWith legacy code generation, all of this, i.e. steps 1-3, need to happen in a single inline assembly block and the function call in (2) needs to be a call to a user-defined assembly function (see below for examples of affected Yul snippets). Also note that during legacy code generation, the Yul optimizer is only run on inline assembly snippets that do not refer to Solidity variables, further reducing the amount of potentially affected cases.\n\nHowever, when using via-IR code generation the entire contract is first translated to Yul and then optimized as a whole. In this case, 1-3 can happen in Solidity code and only the function called in (2) needs to involve an inline assembly block calling `return(...)` or `stop()` (the compiler will not generate `return(...)` or `stop()` instructions that can trigger the bug without the use of inline assembly). Note that due to inlining, this inline assembly block can also merely occur in another nested function call, i.e. any call in (2) that, through any chain of nested calls, can both return to the caller and terminate via assembly is susceptible.\n\nThe following is a minimal example that will exhibit the bug if compiled via IR with enabled optimizer:\n\n```solidity\ncontract C {\n\tuint public x;\n\tfunction f(bool a) public {\n\t\tx = 1; // This write is removed due to the bug.\n\t\tg(a);\n\t\tx = 2;\n\t}\n\tfunction g(bool a) internal {\n\t\t// The relevant part of this function is that it can\n\t\t// both return to the caller and terminate the transaction.\n\t\t// The bug will show its effects in the cases in which\n\t\t// the transaction is terminated (i.e. if a is false).\n\t\t// In this case the write x = 1 above will be missing.\n\t\tif (a) return;\n\t\tassembly { return(0,0) }\n\t}\n}\n```\n\nCompiling the above via IR with enabled optimizer will result in `f(false)` incorrectly terminating the transaction without modifying `x`.\n\nFor a concrete contract, the optimizer may still prevent the bug by inlining the function before running the problematic optimizer step, e.g. the following contract is almost identical, but unaffected, since `g()` will be inlined (in the snippet above the Solidity-level `return;` prevents easy inlining):\n\n```solidity\ncontract C {\n\tuint public x;\n\tfunction f(bool a) public {\n\t\tx = 1;\n\t\tg(a);\n\t\tx = 2;\n\t}\n\tfunction g(bool a) internal {\n\t\tif (!a)\n\t\t\tassembly { return(0,0) }\n\t}\n}\n```\n\nTo check whether your contract is actually affected, you need to trigger the condition leading to the assembly `return(...)` or `stop()` and verify that all storage writes that should have happened in the code leading to it were correctly performed.\n\n## Technical Details\n\nThe Yul optimizer step responsible for the bug is the Unused Store Eliminator (abbreviated as `S` in the [optimizer step sequence](https://docs.soliditylang.org/en/latest/yul.html#optimization-step-sequence)). It is meant to remove storage writes that it can determine to be redundant. A storage write is considered redundant, if in all code paths continuing after it either of the following happens, before the value could ever be read back again:\n\n- A subsequent write overwrites the value written in the initial write.\n- The code path unconditionally reverts.\n\nSo similarly to above, the general pattern is:\n\n1. a storage write (potentially within complex control flow), then\n2. potentially unrelated code, and finally\n3. any continuing control flow path either overwrites the storage write in (1) with a different value or reverts.\n\nThe bug is due to the treatment of certain function calls in (2).\n\nIf a function call is performed between (1) and (3), the optimizer has to consider the control flow behaviour of the function call, e.g. whether control flow may continue beyond the call, whether the called function always reverts or always successfully terminates. However, in the case that the control flow conditionally can continue after the call to a function, but the function call may also terminate using the `return(...)` or `stop()` statements (see examples below), the optimizer incorrectly still behaved as if the control flow _always_ continued after the function.\n\nHence the write in (1) could be removed, even though (2) can in fact terminate and is supposed to retain the storage write in (1).\n\nSo on the Yul level the issue manifests if the following sequence occurs within a Yul block during optimization:\n\n1. A storage write occurs (e.g. `sstore(0, 1)`, but the write may also occur within complex control flow like a single `switch` case).\n2. A user-defined function is called and this function both has a control flow path that terminates the transaction and a control flow path out of the function.\n3. Any continuing control flow path does either of the following:\n   - It overwrites the storage slot written in (1), s.t. the storage write in (1) becomes redundant for this path (e.g. `sstore(0, 2)`).\n   - The control flow unconditionally reverts (e.g. `revert(0, 0)`)\n\nIn this situation, the optimizer will treat the storage write in (1) as redundant and remove it, despite the fact that the called Yul function may successfully terminate the EVM call, in which case this storage write is in fact not redundant at all.\n\nThe following is a full example of an affected Yul snippet:\n\n```yul\n{\n\tfunction f() {\n\t\tif gt(calldatasize(), 4) { leave }\n\t\treturn(0, 0)\n\t}\n\tsstore(0, 1) // This sstore will incorrectly be removed.\n\tf()\n\tsstore(0, 2)\n}\n```\n\nIn the absence of the bug, the first `sstore` would have been marked as required by the optimizer upon encountering the call to `f()`, i.e. it should not be considered for removal regardless of what happens afterwards, since the control flow path of `f()` reaching the `return(0, 0)` already relies on the `sstore` happening.\nHowever, the optimizer failed to mark it as such, marking the first `sstore` as redundant instead once it sees the second `sstore` overwriting the slot.\n\nThe issue only occurs in the presence of a call to a conditionally terminating Yul function that survives the preceding optimizer steps.\nThe following very similarly looking snippet is not affected, since the optimizer will inline the call to `f()` before performing\nthe buggy optimization step:\n\n```yul\n{\n\tfunction f() {\n\t\tif iszero(lt(calldatasize(), 4)) { return(0,0) }\n\t}\n\tsstore(0, 1)\n\tf()\n\tsstore(0, 2)\n}\n```\n\nIn this case, `f()` will be inlined, resulting in\n\n```yul\n{\n\tsstore(0, 1)\n\tif iszero(lt(calldatasize(), 4)) { return(0,0) }\n\tsstore(0, 2)\n}\n```\n\nIn which case both `sstore`s are correctly retained.\n\nHowever, note that the optimizer determines the properties in question transitively, so the following is still affected as well, even if we assume that `emptyReturn` is not inlined:\n\n```yul\n{\n\tfunction emptyReturn() { return(0, 0) }\n\tfunction f() {\n\t\tif iszero(lt(calldatasize(), 4)) { emptyReturn() }\n\t}\n\tsstore(0, 1)\n\tf()\n\tsstore(0, 2)\n}\n```\n","availableURLs":["/2023/05/10/solidity-0.8.20-release-announcement","/2023/03/10/solidity-developer-survey-2022-results","/2023/02/22/user-defined-operators","/2023/02/22/solidity-0.8.19-release-announcement","/2023/02/01/solidity-0.8.18-release-announcement","/2022/12/07/solidity-developer-survey-2022-announcement","/2022/12/05/solidity-core-team-updates","/2022/09/08/storage-write-removal-before-conditional-termination","/2022/09/08/solidity-0.8.17-release-announcement","/2022/08/08/solidity-0.8.16-release-announcement","/2022/08/08/calldata-tuple-reencoding-head-overflow-bug","/2022/06/15/solidity-0.8.15-release-announcement","/2022/06/15/inline-assembly-memory-side-effects-bug","/2022/06/15/dirty-bytes-array-to-storage-bug","/2022/05/17/solidity-0.8.14-release-announcement","/2022/05/17/data-location-inheritance-bug","/2022/05/17/calldata-reencode-size-check-bug","/2022/05/03/solidity-summit-2022-recap","/2022/04/08/announcing-the-underhanded-contest-winners-2022","/2022/03/16/solidity-0.8.13-release-announcement","/2022/03/16/encodecall-bug","/2022/02/22/solidity-summit-2022-announcement","/2022/02/16/solidity-0.8.12-release-announcement","/2022/02/09/underhanded-solidity-contest-2022-announcement","/2022/02/07/solidity-developer-survey-2021-results","/2021/12/20/solidity-0.8.11-release-announcement","/2021/11/18/solidity-developer-survey-2021","/2021/11/09/solidity-0.8.10-release-announcement","/2021/09/29/user-defined-value-types-bug","/2021/09/29/solidity-0.8.9-release-announcement","/2021/09/29/signed-immutables-bug","/2021/09/27/user-defined-value-types","/2021/09/27/solidity-0.8.8-release-announcement","/2021/08/11/solidity-0.8.7-release-announcement","/2021/06/22/solidity-0.8.6-release-announcement","/2021/06/10/solidity-0.8.5-release-announcement","/2021/05/03/soliditylangorg-umbrella-domain","/2021/04/21/solidity-0.8.4-release-announcement","/2021/04/21/decoding-from-memory-bug","/2021/04/21/custom-errors","/2021/04/01/announcing-solidity-collectibles","/2021/03/23/solidity-0.8.3-release-announcement","/2021/03/23/keccak-optimizer-bug","/2021/03/02/solidity-0.8.2-release-announcement","/2021/03/02/saving-gas-with-simple-inliner","/2021/02/15/contributing-to-solidity-101","/2021/02/10/an-introduction-to-soliditys-fuzz-testing-approach","/2021/02/01/launching-the-solidity-forum","/2021/01/27/solidity-0.8.1-release-announcement","/2021/01/26/solidity-developer-survey-2020-results","/2020/12/16/solidity-v0.8.0-release-announcement","/2020/12/16/solidity-0.7.6-release-announcement","/2020/12/09/solidity-developer-survey-2020","/2020/12/03/solidity-underhanded-contest-winners","/2020/11/18/solidity-0.7.5-release-announcement","/2020/11/04/solidity-ama-1-recap","/2020/10/28/solidity-0.8.x-preview","/2020/10/19/solidity-0.7.4-release-announcement","/2020/10/19/empty-byte-array-copy-bug","/2020/10/07/solidity-dynamic-array-cleanup-bug","/2020/10/07/solidity-0.7.3-release-announcement","/2020/09/28/solidity-0.7.2-release-announcement","/2020/09/21/solidity-underhanded-contest","/2020/09/18/meet-the-team","/2020/09/02/solidity-0.7.1-release-announcement","/2020/07/28/solidity-v0.7.0-release-announcement","/2020/07/22/Solidity-0612-release-announcement","/2020/07/08/solidity-turns-5","/2020/07/07/Solidity-0611-release-announcement","/2020/06/25/sourcify-faq","/2020/06/18/solidity-0.6-inheritance","/2020/06/11/Solidity-0610-release-announcement","/2020/06/09/solidity-summit-recap","/2020/06/05/Solidity-069-release-announcement","/2020/06/02/Sourcify-Towards-Safer-Contract-Interaction-for-Humans","/2020/05/26/array-slices","/2020/05/14/Solidity-068-release-announcement","/2020/05/13/immutable-keyword","/2020/05/04/solidity-0.6.7-release-announcement","/2020/04/17/Solidity-Summit-2020-Goes-Interspace","/2020/04/09/solidity-0.6.6-release-announcement","/2020/04/06/solidity-0.6.5-release-announcement","/2020/04/06/memory-creation-overflow-bug","/2020/03/23/fallback-receive-split","/2020/03/17/solidity-0.5.17-release-announcement","/2020/03/10/solidity-0.6.4-release-announcement","/2020/02/18/solidity-0.6.3-release-announcement","/2020/01/29/solidity-0.6-try-catch","/2020/01/27/solidity-0.6.2-release-announcement","/2020/01/02/solidity-0.6.1-release-announcement","/2020/01/02/solidity-0.5.16-release-announcement","/2019/12/17/solidity-0.6.0-release-announcement","/2019/12/17/solidity-0.5.15-release-announcement","/2019/12/09/solidity-0.5.14-release-announcement","/2019/11/14/solidity-0.5.13-release-announcement","/2019/10/01/solidity-0.5.12-release-announcement","/2019/08/12/solidity-0.5.11-release-announcement","/2019/06/25/solidity-storage-array-bugs","/2019/06/25/solidity-0.5.10-release-announcement","/2019/05/28/solidity-0.5.9-release-announcement","/2019/04/30/solidity-0.5.8-release-announcement","/2019/04/29/solidity-0.4.26-release-announcement","/2019/03/26/solidity-optimizer-and-abiencoderv2-bug","/2019/03/26/solidity-0.5.7-release-announcement","/2019/03/13/solidity-0.5.6-release-announcement","/2019/03/05/solidity-0.5.5-release-announcement","/2019/02/12/solidity-0.5.4-release-announcement","/2019/01/22/solidity-0.5.3-release-announcement","/2018/12/19/solidity-0.5.2-release-announcement","/2018/12/03/solidity-0.5.1-release-announcement","/2018/11/13/solidity-0.5.0-release-announcement","/2018/09/13/solidity-bugfix-release","/2018/09/13/solidity-0.4.25-release-announcement","/2018/05/16/solidity-0.4.24-release-announcement","/2018/04/19/solidity-0.4.23-release-announcement","/2018/04/17/solidity-0.4.22-release-announcement","/2018/03/08/solidity-0.4.21-release-announcement","/2018/02/14/solidity-0.4.20-release-announcement","/2017/11/30/solidity-0.4.19-release-announcement","/2017/10/18/solidity-0.4.18-release-announcement","/2017/09/21/solidity-0.4.17-release-announcement","/2017/08/24/solidity-0.4.16-release-announcement","/2017/08/08/solidity-0.4.15-release-announcement","/2017/07/31/solidity-0.4.14-release-announcement","/2017/07/06/solidity-0.4.13-release-announcement","/2017/07/03/solidity-0.4.12-release-announcement","/2017/05/03/solidity-optimizer-bug","/2017/05/03/solidity-0.4.11-release-announcement","/2017/03/15/solidity-0.4.10-release-announcement","/2017/01/31/solidity-0.4.9-release-announcement","/2017/01/13/solidity-0.4.8-release-announcement","/2016/12/15/solidity-0.4.7-release-announcement","/2016/11/22/solidity-0.4.6-release-announcement","/2016/11/21/solidity-0.4.5-release-announcement","/2016/11/09/analysis-storage-corruption-bug","/2016/11/01/solidity-0.4.4-release-announcement","/2016/11/01/security-alert-solidity-variables-can-overwritten-storage","/2016/10/25/solidity-0.4.3-release-announcement","/2016/09/17/solidity-0.4.2-release-announcement","/2016/09/09/solidity-0.4.1-release-announcement","/2016/09/08/solidity-0.4.0-release-announcement","/2016/09/01/formal-methods-roadmap","/2016/08/10/solidity-0.3.6-release-announcement","/2016/06/10/solidity-0.3.5-release-announcement","/2016/06/10/smart-contract-security","/2016/05/31/solidity-0.3.4-release-announcement","/2016/05/27/solidity-0.3.3-release-announcement","/2016/04/18/solidity-0.3.2-release-announcement","/2016/03/31/solidity-0.3.1-release-announcement","/2016/03/11/solidity-0.3.0-release-announcement","/2016/02/17/solidity-0.2.2-release-announcement","/2016/01/30/solidity-0.2.1-release-announcement","/2015/12/01/solidity-0.2.0-release-announcement","/2015/11/17/solidity-0.1.7-release-announcement","/2015/10/16/solidity-0.1.6-release-announcement","/2015/10/07/solidity-0.1.5-release-announcement","/2015/09/30/solidity-0.1.4-release-announcement","/2015/09/22/solidity-0.1.3-release-announcement","/2015/08/21/solidity-0.1.2-release-announcement"]},"__N_SSG":true}