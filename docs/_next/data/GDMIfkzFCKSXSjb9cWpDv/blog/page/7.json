{"pageProps":{"allPostsData":[{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.7.2 Release Announcement","date":"2020-09-28","author":"Solidity Team","category":"Releases"},"content":"\nSolidity v0.7.2 fixes a bug in free functions, which had been introduced with v0.7.1, and adds compiler-generated utility file export. Furthermore, it comes with a considerably broadened language support of the SMTChecker.\n\nImportant Bugfixes\n\nFree Function Overloading Checks\n\nFree functions were introduced in the previous release (Solidity v0.7.1). It turned out that it was possible\nto define a function with the same name multiple times, even containing the same parameter types.\nAllowing two functions with the same name, but different parameter types is called \"overloading\"\nand...","url":"/blog/2020/09/28/solidity-0.7.2-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"The Underhanded Solidity Contest is back!","date":"2020-09-21","author":"Franziska Heintel","category":"Announcements"},"content":"\nWe're excited to share that the Underhanded Solidity Contest is finally back!\n\nInspired by the Underhanded C Contest and the first Underhanded Solidity Contest, organized in 2017 by Nick Johnson, we decided it is time for a much needed revival.\n\nUnderhanded Solidity Contest\n\nThe goal of this contest is to write innocent-looking Solidity code, which pretends to be clear and straightforward, but actually contains malicious behavior or backdoors.\n\nBy hosting such a contest we aim to:\n\nRaise awareness about smart contract security.\nUncover language design flaws.\nBattle-test...","url":"/blog/2020/09/21/solidity-underhanded-contest"},{"frontmatter":{"layout":"post","published":true,"title":"Meet the Solidity team! üßë‚Äçüíªüë©‚Äçüíª","date":"2020-09-18","author":"Solidity Team","category":"Announcements"},"content":"\nAs you might know, Solidity is an open-source community project mainly developed and maintained by a core team.\n\nToday, we would like to introduce some of our team members and share insights into their professional background, which components of Solidity they mostly work on, what they would like to see in Solidity and in the ecosystem in future and more! Since almost all of our work happens on Github you can find each team member's Github handle next to their name.\n\nBefore...","url":"/blog/2020/09/18/meet-the-team"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.7.1 Release Announcement","date":"2020-09-02","author":"Solidity Team","category":"Releases"},"content":"\nSolidity v0.7.1 adds functions at file-level and fixes several small bugs.\n\nNotable New Features\n\nFunctions At File-Level\n\nFunctions can now be defined at file-level. Such functions are called \"free functions\"\n(as opposed to functions bound to a specific contract).\n\nFree functions are always internal functions\nand are meant to replace internal library functions and their very special behaviour.\n\nA free function behaves like an internal function of the contract that called it.\nThe main difference is that a free function cannot directly access state variables and internal\nfunctions of...","url":"/blog/2020/09/02/solidity-0.7.1-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.7.0 Release Announcement","date":"2020-07-28","author":"Solidity Team","category":"Releases"},"content":"\nSolidity 0.7.0 is a breaking release of the Solidity compiler and language.\n\nThis release does not include many features but rather changes that require a\nbackwards-incompatible adjustment in syntax or semantics. For a detailed explanation,\nplease see the documentation.\n\nMost notably, further cleanup of visibility and state mutability has been performed\nand several unpopular keywords have been removed. Types with mappings\nin memory are disallowed and shift and exponentiation operations use more reasonable types.\n\nSince we usually do not backport bugfixes, it is recommended to upgrade all...","url":"/blog/2020/07/28/solidity-v0.7.0-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.6.12 Release Announcement","date":"2020-07-22","author":"Solidity Team","category":"Releases"},"content":"\nSolidity v0.6.12 adds more flexibility\nwhen using inheritance with NatSpec comments and introduces many small improvements to the optimizer.\n\nNotable New Features\n\nNatSpec Inheritance\n\nAs explained in the Solidity 0.6.11 release announcement,\nNatSpec comments are now inherited automatically if you do not provide any\nNatSpec in the derived function. Starting from Solidity 0.6.12, you can\nexplicitly inherit comments from a base contract using the tag @inheritdoc\neven if you specify some of the tags.\nThe tags that are not given will then be taken from the specified base class'\nfunction.\n\n//...","url":"/blog/2020/07/22/Solidity-0612-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity v0.1.0 turns 5! A walk down memory lane...","date":"2020-07-08","author":"Franziska Heintel","category":"Announcements"},"content":"\nSolidity v0.1.0 turns 5\n\nWith happiness and a tad of nostalgia, we'd like to share that Solidity v0.1.0 turns 5 years old today! (To be fair, v0.1.0 wasn't an actual release, but it marks the time where the Solidity team started appointing version numbers.) We are puzzled over how fast time flew by. We'd like to use this opportunity to take a look back and walk down the Solidity memory lane together with you.\n\nIn short: The Solidity language evolved rapidly, the...","url":"/blog/2020/07/08/solidity-turns-5"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.6.11 Release Announcement","date":"2020-07-07","author":"Solidity Team","category":"Releases"},"content":"\nSolidity v0.6.11 adds inheritance to NatSpec comments,\nimproves debugging data output and fixes some minor issues with opening up calldata for non-external functions.\n\nNotable New Features\n\nNatSpec Inheritance and on Events\n\nNatSpec comments are a way to describe the behaviour of a function to end-users. It also allows\nto provide more detailed information to developers.\n\nOne regular use-case is that you document the behaviour of an interface and then implement\nthe interface in a derived contract. Previously, you had to repeat the documentation in the derived\ncontract. This...","url":"/blog/2020/07/07/Solidity-0611-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"All you need to know about Sourcify","date":"2020-06-25","author":"Franziska Heintel","category":"Explainers"},"content":"\nWelcome to Sourcify's first short FAQ! If your questions around source verification haven't been answered after reading\nthis post, please feel free to drop by the Sourcify Gitter channel and ask us\nany question there. Also stay tuned on more turorials and developer focused content to follow here and on the Remix blog!\n\nSource Verification\n\nWhat is source verification?\n\nSolidity contract source code can be verified by checking whether the on-chain deployed code\nis matching with published source code files. In order to allow for source...","url":"/blog/2020/06/25/sourcify-faq"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.6.x features: inheritance","date":"2020-06-18","author":"Elena Gesheva","category":"Explainers"},"content":"\nSimilar to object-oriented programming in Solidity - a contract-oriented language - the inheritance and polymorphism features are as widely adopted and critical for the language evolution. There is hardly any Solidity developer who hasn't used these language features in their contracts to decouple logic and increase code reuse. With version 0.6 of the language the main improvements introduced are to make existing rules explicit in addition to introducing interface inheritance and disallowing the dangerous state variable shadowing. The compiler continues...","url":"/blog/2020/06/18/solidity-0.6-inheritance"}],"page":7,"totalPages":16},"__N_SSG":true}