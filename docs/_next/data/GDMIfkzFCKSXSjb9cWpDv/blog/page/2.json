{"pageProps":{"allPostsData":[{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.8.15 Release Announcement","date":"2022-06-15","author":"Solidity Team","category":"Releases"},"content":"\nSolidity v0.8.15\nfixes two important bugs, improves inlining heuristics and adds a .selector member for errors and events.\n\nImportant Bugs\n\nThe first one is an optimizer bug that can lead to memory write operations in inline assembly being removed if\nthe result of such an operation is not read back from within the same assembly block.\nThe bug can be triggered only when using the default legacy compiler pipeline (the new compilation pipeline via\nIR is not affected) and happens only in assembly blocks that never...","url":"/blog/2022/06/15/solidity-0.8.15-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"Optimizer Bug Regarding Memory Side Effects of Inline Assembly","date":"2022-06-15","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn June 5, 2022, John Toman of the Certora development team reported an optimizer bug\nthat can cause memory writes in inline assembly blocks to be incorrectly removed\nunder certain conditions.\n\nThe bug was introduced in Solidity 0.8.13 with a new Yul optimizer step meant to\nremove unused writes to memory and storage.\n\nWe assigned the bug a severity of \"medium\".\n\nWhich Contracts are Affected?\n\nThe Yul optimizer considers all memory writes in the outermost Yul block that are\nnever read from as unused and removes them. This...","url":"/blog/2022/06/15/inline-assembly-memory-side-effects-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Bug when Copying Dirty Bytes Arrays to Storage","date":"2022-06-15","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn July 1, 2021, a bug in the Solidity code generator was found by differential fuzzing.\nThe bug causes the legacy code generation pipeline to generate code that\nmay write dirty values to storage when copying bytes arrays from calldata or memory.\n\nInitially, it was assumed that the dirty values in storage are only observable using inline\nassembly. However, resizing a bytes array using an empty .push() without actually\nwriting values to it, can expose the dirty bytes without any use of inline assembly.\n\nThe bug...","url":"/blog/2022/06/15/dirty-bytes-array-to-storage-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.8.14 Release Announcement","date":"2022-05-18","author":"Solidity Team","category":"Releases"},"content":"\nSolidity v0.8.14\nfixes two important bugs.\n\nThe first one is related to ABI-encoding nested arrays directly from calldata.\nYou can find more information in the blog post.\n\nThe second bug is triggered in certain inheritance structures and can\ncause a memory pointer to be interpreted as a calldata pointer or\nvice-versa. We also have a dedicated blog post about this bug.\n\nApart from these, there are several minor bug fixes and improvements.\n\nPlease note: Unfortunately, the npm wrapper package of this version is corrupted. Using the new soljson.js...","url":"/blog/2022/05/17/solidity-0.8.14-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"Bug Concerning Data Location during Inheritance","date":"2022-05-17","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn February 5th 2021, Nicolas Venturo reported a bug that allows\noverriding functions to change the data location of parameters from\nmemory to calldata.\n\nThe bug was introduced in Solidity 0.6.9 together with the ability to use calldata\ndata location for all variables (and not just parameters of external functions).\n\nWe assigned the bug a severity of \"very low\".\n\nWhich Contracts are Affected?\n\nThe effect of the bug is that a memory pointer is interpreted as a calldata pointer\nor vice-versa. It can only happen if you change...","url":"/blog/2022/05/17/data-location-inheritance-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Size Check Bug in Nested Calldata Array ABI-Reencoding","date":"2022-05-17","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn April 7, 2022, a bug in the Solidity code generator was reported by\nJohn Toman of the Certora development team. Certora's bug disclosure post can be found here.\n\nThe bug is fixed with Solidity version 0.8.14\nreleased on May 17, 2022. The bug was first introduced in Solidity version 0.5.8.\n\nWe assigned the bug a severity of \"very low\".\n\nWhich Contracts are Affected?\n\nYou might be affected if you pass a nested array directly to another external\nfunction call or use abi.encode on it.\n\nIf calldata is...","url":"/blog/2022/05/17/calldata-reencode-size-check-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity Summit 2022 Recap","date":"2022-05-03","author":"Franziska Heintel","category":"Announcements"},"content":"\nWe can't believe it's already been two weeks since we met in Amsterdam for the second Solidity Summit!\n\nSolidity Summit 2022 was part of Devconnect and took place on Wednesday, April 20, 2022.\n\nWith roughly 250 participants, the event was well attended. In addition, approximately 400 people joined remotely by watching the Livepeer livestream.\n\nThe day was packed with 20+ talks on\n\nSolidity internals & deep dives\nSolidity language design\nSolidity tooling\nSecurity\nProgramming patterns\n\n... and more.\n\nThe full agenda of the day can be found here. You can...","url":"/blog/2022/05/03/solidity-summit-2022-recap"},{"frontmatter":{"layout":"post","published":true,"title":"Announcing the Winners of the Underhanded Solidity Contest 2022","date":"2022-04-09","author":"Franziska Heintel & USC Judges","category":"Announcements"},"content":"\nThe time has come to share this year's winners of the Underhanded Solidity Contest!\n\nBefore we dive into the winning submissions, let's revisit the most important features of the USC:\n\nIn a nutshell, the USC is about finding loopholes or “hiding spots” in the Solidity language and using those to write seemingly innocent and straightforward-looking Solidity code which contains malicious behavior or backdoors.\n\nThe Underhanded Solidity Contest aims to...\n\nRaise awareness about smart contract security.\nUncover language design faults.\nBattle-test recently introduced language features and restrictions.\nHighlight...","url":"/blog/2022/04/08/announcing-the-underhanded-contest-winners-2022"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.8.13 Release Announcement","date":"2022-03-16","author":"Solidity Team","category":"Releases"},"content":"\nSolidity v0.8.13\nfixes an important bug related to abi.encodeCall, extends the using for\ndirective and implements \"go to definition\" for the language server.\n\nFurthermore, compiling via the new Yul IR pipeline is now considered production ready.\n\nImportant Bugs\n\nWhen abi.encodeCall was introduced in Solidity 0.8.11,\nhex literals (0x1234) and string literals (\"abcd\") were not handled properly.\nPlease read more about it in the security alert.\n\nNotable New Features\n\nYul IR Pipeline Production Ready\n\nWe have been working on Yul as an intermediate language for Solidity for several years now.\nYul in...","url":"/blog/2022/03/16/solidity-0.8.13-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"abi.encodeCall Literals Bug","date":"2022-03-16","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn March 10th, 2022, the Solidity team discovered a bug in the implementation of\nabi.encodeCall when used together with fixed-length bytes literals.\n\nIt was introduced together with abi.encodeCall in Solidity 0.8.11 and is fixed in 0.8.13.\n\nWe assigned the bug a severity of \"very low\".\n\nWhich Contracts are Affected?\n\nYou might be affected if you use abi.encodeCall(f, (...)) where f takes a\nbytesNN parameter and you provide the value for that parameter either as a\nhex literal (0x1234 or hex\"abcd\") or\nas a string literal (\"abcd\").\n\nIf you only...","url":"/blog/2022/03/16/encodecall-bug"}],"page":2,"totalPages":16},"__N_SSG":true}