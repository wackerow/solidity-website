{"pageProps":{"allPostsData":[{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.6.5 Release Announcement","date":"2020-04-06","author":"Solidity Team","category":"Releases"},"content":"\nVersion 0.6.5 of Solidity fixes an important bug and introduces immutable as a major feature.\n\nThe bug concerns the allocation of dynamic memory arrays using e.g. new uint. The bug is considered to have a severity level of \"low\" but is present in all prior versions of Solidity. Therefore, please read more about how check if your contract is vulnerable in this blog post.\n\nThe immutable feature supports setting contract-level variables at construction time if they do not change later on. These...","url":"/blog/2020/04/06/solidity-0.6.5-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity Memory Array Creation Overflow Bug","date":"2020-04-06","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn the 28th of March, a bug in the Solidity code generator was reported through the\nEthereum Foundation Bounty program,\nby John Toman of Certora. The bug is fixed with version 0.6.5,\nreleased on 2020-04-06.\nThe bug is present in all prior versions of Solidity.\n\nWe assigned a severity level of \"low\" because we found the bug to be uncommon and at the same time hard to exploit.\n\nWho should be concerned\n\nIf you have deployed a contract which allocates a memory array of user-supplied length,\nbut does...","url":"/blog/2020/04/06/memory-creation-overflow-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.6.x features: fallback and receive functions","date":"2020-03-26","author":"Elena Gesheva","category":"Explainers"},"content":"\nIn versions of Solidity before 0.6.x, developers typically used the fallback function to handle logic in two scenarios:\n\ncontract received ether and no data\ncontract received data but no function matched the function called\n\nThe main use case of the pre-0.6.x fallback function is to receive ether and react\nto it, a typical pattern used by token-style contracts to reject transfers, emit\nevents or forward the ether. The function executes when a contract is called\nwithout any data e.g. via .send() or .transfer() functions. The 0.5.x\nsyntax...","url":"/blog/2020/03/23/fallback-receive-split"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.5.17 Release Announcement","date":"2020-03-17","author":"Solidity Team","category":"Releases"},"content":"\nThis maintenance release of the 0.5.x series fixes a bug that was always present in the compiler. Some people do not even consider it a bug, though, which might explain why it was undiscovered for so long:\n\nA private function can be overridden in a derived contract by a private function of the same name and types. In other words, the virtual function calling mechanism does not respect visibility.\nThe same applies to two private functions of the same name and type...","url":"/blog/2020/03/17/solidity-0.5.17-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.6.4 Release Announcement","date":"2020-03-10","author":"Solidity Team","category":"Releases"},"content":"\nVersion 0.6.4 of Solidity fixes a bug that did not allow calling base contract functions directly, another bug that caused issues with variable scoping in try/catch and it allows for greater flexibility with regards to storage: It is now possible to set storage slots for storage reference variables from inline assembly. We expect this to allow new patterns in connection to delegatecall proxies and upgradable contracts. Please be careful when using this feature!\n\nLanguage Features:\n\nGeneral: Deprecated value(...) and gas(...) in favor...","url":"/blog/2020/03/10/solidity-0.6.4-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.6.3 Release Announcement","date":"2020-02-18","author":"Solidity Team","category":"Releases"},"content":"\nThis release adds reason strings for compiler-generated reverts if you specify revert-strings debug or use the setting settings.debug.revertStrings = \"debug\". Furthermore, contract types and enums are now allowed as keys for mappings and the doxygen-style comments are better supported by the AST.\n\nLanguage Features:\n\nAllow contract types and enums as keys for mappings.\nAllow function selectors to be used as compile-time constants.\n\nCompiler Features:\n\nAST: Add a new node for doxygen-style, structured documentation that can be received by contract, function, event and modifier definitions.\nCode Generator:...","url":"/blog/2020/02/18/solidity-0.6.3-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.6.x features: try/catch statement","date":"2020-01-29","author":"Elena Gesheva","category":"Explainers"},"content":"\nThis post was originally published on the Ethereum blog.\n\nThe try/catch syntax introduced in 0.6.0 is arguably the biggest leap in error handling capabilities in Solidity, since reason strings for revert and require were released in v0.4.22. Both try and catch have been reserved keywords since v0.5.9 and now we can use them to handle failures in external function calls without rolling back the complete transaction (state changes in the called function are still rolled back, but the ones in the...","url":"/blog/2020/01/29/solidity-0.6-try-catch"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.6.2 Release Announcement","date":"2020-01-27","author":"Solidity Team","category":"Releases"},"content":"\nAfter long discussions, we finally enabled a high-level way to use the create2 opcode introduced in Constantinople: When creating a contract, you can specify the salt as a \"function call option\": new Contract{salt: 0x1234}(arg1, arg2). We took this opportunity and also extended the use of these function call options to specifying the gas and value options in external function calls: c.f{value: 10, gas: 20000}(arg1, arg2).\n\nFurthermore, interfaces can now inherit from interfaces, making them even more useful for specification purposes.\n\nTo allow...","url":"/blog/2020/01/27/solidity-0.6.2-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.6.1 Release Announcement","date":"2020-01-02","author":"Solidity Team","category":"Releases"},"content":"\nThis release fixes a bug in the Yul optimizer related to break and continue statements in loops. The Yul optimizer is part of the regular optimizer since version 0.6.0. In version 0.5.x, you had to explicitly activate the Yul optimizer in addition to the regular optimizer. The Yul optimizer only operates on the code generated by ABIEncoderV2 or if you use it in a stand-alone way. The code generated by ABIEncoderV2 does not make use of break and continue, but...","url":"/blog/2020/01/02/solidity-0.6.1-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.5.16 Release Announcement","date":"2020-01-02","author":"Solidity Team","category":"Releases"},"content":"\nThis release fixes a bug in the Yul optimizer. You are only affected if you manually enabled the Yul optimizer (not the regular optimizer) and either used Yul stand-alone or via ABIEncoderV2. For more details, please see buglist.json.\n\nBugfixes:\n\nYul Optimizer: Fix bug in redundant assignment remover in combination with break and continue statements.\n\nA big thank you to all contributors who helped make this release possible!\n\nDownload the new version of Solidity here.\n","url":"/blog/2020/01/02/solidity-0.5.16-release-announcement"}],"page":9,"totalPages":16},"__N_SSG":true}