{"pageProps":{"allPostsData":[{"frontmatter":{"layout":"post","published":true,"title":"User Defined Value Types in Solidity","date":"2021-09-27","author":"Solidity Team","category":"Explainers"},"content":"\nSolidity v0.8.8 introduces user defined\nvalue types as a\nmeans to create zero-cost abstractions over an elementary value type that also increases type safety\nand improves readability.\n\nMotivation\n\nA problem with primitive value types is that they are not very descriptive: they only specify how\nthe data is stored and not how it should be interpreted. For example, one may want to use uint128\nto store the price of some object as well as the quantity available. It is quite useful to have\nstricter type rules to avoid...","url":"/blog/2021/09/27/user-defined-value-types"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.8.8 Release Announcement","date":"2021-09-27","author":"Solidity Team","category":"Releases"},"content":"\nSolidity v0.8.8 introduces user defined\nvalue types as a major feature. The override keyword is now optional for interface functions,\nimmutable variables can be read in the constructor, there is support for retrieving the smallest\nand largest value of an enum, you can specify include directories and the commandline interface was cleaned up.\nFurthermore, we fixed several bugs and the SMTChecker has improved language coverage.\n\nNotable New Features\n\nUser Defined Value Types\n\nA user defined value type allows creating a zero-cost-abstraction over an elementary value type that\nalso...","url":"/blog/2021/09/27/solidity-0.8.8-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.8.7 Release Announcement","date":"2021-08-11","author":"Solidity Team","category":"Releases"},"content":"\nSolidity v0.8.7 introduces support for\nthe London upgrade, includes\nvarious improvements to Yul to EVM code transformation, the SMTChecker and some bugfixes.\n\nPlease note: Unfortunately, the npm package of this version is corrupted. Pulling the solc-js repository directly will work.\n\nSupport for London Upgrade\n\nSolidity adds support for the BASEFEE opcode (EIP-3198\nand EIP-1559) which exposes the block's base fee. This\ncan be accessed via the global block.basefee or using basefee() in inline assembly or Yul.\n\nThe following contract illustrates an example:\n\ncontract Basefee {\n    function...","url":"/blog/2021/08/11/solidity-0.8.7-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.8.6 Release Announcement","date":"2021-06-22","author":"Solidity Team","category":"Releases"},"content":"\nSolidity v0.8.6 fixes some\nnon-critical but annoying bugs, especially a warning about unreachable code that\nis in fact reachable.\n\nBugfixes\n\nUnreachable Warning\n\nWith Solidity 0.8.5, we released a new feature that detects if code is unreachable\nbecause a called function always reverts before the code is executed. This detection contained a bug\nin connection with nested calls to internal library functions where the \"reverting behaviour\"\nof a function was not properly updated after a\nfunction called by it was determined to be not always reverting.\n\nBecause the bug was rather...","url":"/blog/2021/06/22/solidity-0.8.6-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.8.5 Release Announcement","date":"2021-06-10","author":"Solidity Team","category":"Releases"},"content":"\nSolidity v0.8.5 allows conversions\nfrom bytes to bytesNN values, adds the verbatim builtin function to inject\narbitrary bytecode in Yul and fixes several smaller bugs.\n\nNotable New Features\n\nBytes Conversion\n\nFind the complete feature documentation here.\n\nThis release introduces the ability to convert bytes and bytes slices to fixed bytes types bytes1 / ... / bytes32. While conversion between fixed-length bytes types has always been possible, it is now also possible to convert dynamically-sized bytes types to fixed-length bytes types.\n\nIn case a byte array is longer...","url":"/blog/2021/06/10/solidity-0.8.5-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"What Happened with Solidity-related Domains?","date":"2021-05-03","author":"Franziska Heintel","category":"Explainers"},"content":"\nSome time ago we decided to get a domain that the Solidity team has easy access to in\norder to streamline efforts and initiatives that were hosted on other domains before.\n\nAnd so soliditylang.org was born! üéâ\n\nWe announced most of these domain changes individually on Twitter, but we want to take a moment to\nalso officially announce it here on the blog\nand explain the various subdomains we have now, what they are for and which older\ndomains may be deprecated in the future.\n\nIn short,...","url":"/blog/2021/05/03/soliditylangorg-umbrella-domain"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity 0.8.4 Release Announcement","date":"2021-04-21","author":"Solidity Team","category":"Releases"},"content":"\nSolidity v0.8.4 adds custom structured errors, bytes.concat(...), allows more flexible\nconfiguration of the SMT checker and fixes a bug in the Solidity ABI decoder v2.\n\nImportant Bugfixes:\n\nOn April 5th, 2021, a bug in the Solidity ABI decoder v2 was reported by John Toman of the Certora development team. For two-dimensional arrays and specially crafted data in memory, the result of abi.decode can depend on data elsewhere in memory. Calldata decoding is not affected. The bug is present in all prior versions of...","url":"/blog/2021/04/21/solidity-0.8.4-release-announcement"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity ABI Decoder Bug For Multi-Dimensional Memory Arrays","date":"2021-04-21","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn April 5th, 2021, a bug in the Solidity ABI decoder v2 was reported by\nJohn Toman of the Certora development team. Certora's bug disclosure post\ncan be found here: Memory Isolation Violation in Deserialization Code.\n\nThe bug is fixed with Solidity version 0.8.4\nreleased on April 21st, 2021. The bug is present in all prior versions of ABI coder v2.\n\nWe assigned the bug a severity level of \"very low\", mainly due to the\nfact that it is very hard to exploit the bug.\n\nWe are...","url":"/blog/2021/04/21/decoding-from-memory-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Custom Errors in Solidity","date":"2021-04-21","author":"Solidity Team","category":"Explainers"},"content":"\nStarting from Solidity v0.8.4, there is\na convenient and gas-efficient way to explain to users why an operation failed through the use of\ncustom errors. Until now, you could already use strings to give more information about failures\n(e.g., revert(\"Insufficient funds.\");), but they are rather expensive, especially when it comes to\ndeploy cost, and it is difficult to use dynamic information in them.\n\nCustom errors are defined using the error statement, which can be used inside and outside of\ncontracts (including interfaces and libraries).\n\nExample\n\nThe following contract...","url":"/blog/2021/04/21/custom-errors"},{"frontmatter":{"layout":"post","published":true,"title":"Announcing Solidity Version Collectibles & Community Governance üíé","date":"2021-04-01","author":"Franziska Heintel","category":"Announcements"},"content":"‚ö†Ô∏è Attention: This post is an April Fools' Day joke. Please consume it at your own risk. We will not distribute any Solidity NFTs in the foreseeable future. Stay safe.\n\nToday, we are excited to announce a little surprise we‚Äôve been working on silently for the last couple of weeks. We heard that you really like crypto-related collectibles and we listened.\n\nYou will soon be able to own a digital piece of Solidity‚Äôs history: We‚Äôre tokenizing each Solidity version as an NFT!...","url":"/blog/2021/04/01/announcing-solidity-collectibles"}],"page":4,"totalPages":16},"__N_SSG":true}