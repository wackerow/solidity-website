{"pageProps":{"categoryPostsData":[{"frontmatter":{"layout":"post","published":true,"title":"Storage Write Removal Bug On Conditional Early Termination","date":"2022-09-08","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn September 5, 2022, a bug in Solidity's Yul optimizer was found by differential fuzzing.\n\nThe bug was introduced in version 0.8.13 and Solidity version 0.8.17, released on September 08, 2022, provides a fix. The bug is significantly easier to trigger with optimized via-IR code generation, but can theoretically also occur in optimized legacy code generation.\n\nWe assigned the bug a severity of \"medium/high\".\n\nWho Should Be Concerned\n\nIf you're using optimized legacy code generation, you only need to be concerned, if you use...","url":"/blog/2022/09/08/storage-write-removal-before-conditional-termination"},{"frontmatter":{"layout":"post","published":true,"title":"Head Overflow Bug in Calldata Tuple ABI-Reencoding","date":"2022-08-08","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn July 5, 2022, Chance Hudson (@vimwitch) from the Ethereum Foundation discovered a bug in the Solidity code generator.\n\nThe earliest affected version of the compiler is 0.5.8, which introduced ABI-reencoding of calldata arrays and structs.\nSolidity version 0.8.16, released on August 08, 2022, provides a fix.\n\nWe assigned the bug a severity of \"medium\".\n\nWhich Contracts are Affected?\n\nThe effects of the bug manifest when a contract performs ABI-encoding of a tuple that meets all of the following conditions:\n\nThe last component of the tuple...","url":"/blog/2022/08/08/calldata-tuple-reencoding-head-overflow-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Optimizer Bug Regarding Memory Side Effects of Inline Assembly","date":"2022-06-15","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn June 5, 2022, John Toman of the Certora development team reported an optimizer bug\nthat can cause memory writes in inline assembly blocks to be incorrectly removed\nunder certain conditions.\n\nThe bug was introduced in Solidity 0.8.13 with a new Yul optimizer step meant to\nremove unused writes to memory and storage.\n\nWe assigned the bug a severity of \"medium\".\n\nWhich Contracts are Affected?\n\nThe Yul optimizer considers all memory writes in the outermost Yul block that are\nnever read from as unused and removes them. This...","url":"/blog/2022/06/15/inline-assembly-memory-side-effects-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Bug when Copying Dirty Bytes Arrays to Storage","date":"2022-06-15","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn July 1, 2021, a bug in the Solidity code generator was found by differential fuzzing.\nThe bug causes the legacy code generation pipeline to generate code that\nmay write dirty values to storage when copying bytes arrays from calldata or memory.\n\nInitially, it was assumed that the dirty values in storage are only observable using inline\nassembly. However, resizing a bytes array using an empty .push() without actually\nwriting values to it, can expose the dirty bytes without any use of inline assembly.\n\nThe bug...","url":"/blog/2022/06/15/dirty-bytes-array-to-storage-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Bug Concerning Data Location during Inheritance","date":"2022-05-17","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn February 5th 2021, Nicolas Venturo reported a bug that allows\noverriding functions to change the data location of parameters from\nmemory to calldata.\n\nThe bug was introduced in Solidity 0.6.9 together with the ability to use calldata\ndata location for all variables (and not just parameters of external functions).\n\nWe assigned the bug a severity of \"very low\".\n\nWhich Contracts are Affected?\n\nThe effect of the bug is that a memory pointer is interpreted as a calldata pointer\nor vice-versa. It can only happen if you change...","url":"/blog/2022/05/17/data-location-inheritance-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Size Check Bug in Nested Calldata Array ABI-Reencoding","date":"2022-05-17","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn April 7, 2022, a bug in the Solidity code generator was reported by\nJohn Toman of the Certora development team. Certora's bug disclosure post can be found here.\n\nThe bug is fixed with Solidity version 0.8.14\nreleased on May 17, 2022. The bug was first introduced in Solidity version 0.5.8.\n\nWe assigned the bug a severity of \"very low\".\n\nWhich Contracts are Affected?\n\nYou might be affected if you pass a nested array directly to another external\nfunction call or use abi.encode on it.\n\nIf calldata is...","url":"/blog/2022/05/17/calldata-reencode-size-check-bug"},{"frontmatter":{"layout":"post","published":true,"title":"abi.encodeCall Literals Bug","date":"2022-03-16","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn March 10th, 2022, the Solidity team discovered a bug in the implementation of\nabi.encodeCall when used together with fixed-length bytes literals.\n\nIt was introduced together with abi.encodeCall in Solidity 0.8.11 and is fixed in 0.8.13.\n\nWe assigned the bug a severity of \"very low\".\n\nWhich Contracts are Affected?\n\nYou might be affected if you use abi.encodeCall(f, (...)) where f takes a\nbytesNN parameter and you provide the value for that parameter either as a\nhex literal (0x1234 or hex\"abcd\") or\nas a string literal (\"abcd\").\n\nIf you only...","url":"/blog/2022/03/16/encodecall-bug"},{"frontmatter":{"layout":"post","published":true,"title":"User Defined Value Types Bug","date":"2021-09-29","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn September 28th, 2021, Harry Altman (@haltman-at) of Truffle\ndiscovered a bug in user defined value types.\n\nThe bug has no influence on the correctness of Solidity contracts, but contracts compiled with\nSolidity 0.8.8 that use the new feature are unnecessarily wasteful and might have problems with\ntooling or contract upgrades.\n\nThe bug exists only in Solidity 0.8.8 and is fixed in 0.8.9.\n\nWe assigned the bug a severity of \"very low\".\n\nStorage Layout of User Defined Value Types\n\nThe compiler did not correctly compute the storage layout...","url":"/blog/2021/09/29/user-defined-value-types-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Signed Immutables Bug","date":"2021-09-29","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn September 28th, 2021, the Solidity team discovered that\nfor immutable variables of a signed integer type shorter than 256 bits,\nsign extension (cleanup) of its value is not always properly performed.\n\nTo our knowledge, the value can only be accessed in its unclean state\nwhen using inline assembly.\nThe bug is present since the introduction of the\nimmutable feature in Solidity 0.6.5 and is fixed in 0.8.9.\n\nWe assigned the bug a severity of \"very low\".\n\nTechnical Details\n\nWhen immutable variables are assigned in Solidity during the construction...","url":"/blog/2021/09/29/signed-immutables-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity ABI Decoder Bug For Multi-Dimensional Memory Arrays","date":"2021-04-21","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn April 5th, 2021, a bug in the Solidity ABI decoder v2 was reported by\nJohn Toman of the Certora development team. Certora's bug disclosure post\ncan be found here: Memory Isolation Violation in Deserialization Code.\n\nThe bug is fixed with Solidity version 0.8.4\nreleased on April 21st, 2021. The bug is present in all prior versions of ABI coder v2.\n\nWe assigned the bug a severity level of \"very low\", mainly due to the\nfact that it is very hard to exploit the bug.\n\nWe are...","url":"/blog/2021/04/21/decoding-from-memory-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity Optimizer Keccak Caching Bug","date":"2021-03-23","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn March 20, 2021, a bug in Solidity's bytecode optimizer was found by differential fuzzing. The bug\nis fixed with version 0.8.3 released on\nMarch 23, 2021. The bug is present in all prior versions of Solidity.\n\nWe assigned the bug a severity level of \"medium\".\n\nTechnical Details\n\nSummary: The bytecode optimizer incorrectly re-used previously evaluated Keccak-256 hashes. You\nare unlikely to be affected if you do not compute Keccak-256 hashes in inline assembly.\n\nSolidity's bytecode optimizer has a step that can compute Keccak-256 hashes, if the...","url":"/blog/2021/03/23/keccak-optimizer-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity Empty Byte Array Copy Bug","date":"2020-10-19","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn October 14, 2020, a bug in the Solidity code generator was reported by\nJohn Toman of the Certora development team. Certora's bug disclosure post can be found here.\n\nThe bug is fixed with Solidity version 0.7.4\nreleased on October 19, 2020. The bug is present in all prior versions of Solidity.\n\nWe assigned the bug a severity level of \"medium\".\n\nWho should be concerned\n\nThis bug can cause newly created elements of bytes or string arrays in storage\nto be initialized by a non-zero value. For...","url":"/blog/2020/10/19/empty-byte-array-copy-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity Dynamic Array Cleanup Bug","date":"2020-10-07","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn September 17, 2020, a bug in the Solidity code generator was found. The bug is fixed with version 0.7.3\nreleased on October 7, 2020. The bug is present in all prior versions of Solidity.\n\nWe assigned the bug a severity level of \"medium\".\n\nTechnical Details of the Bug\n\nSummary: For a dynamically-sized storage-array with types of size at most 16 bytes,\nassignments that require deleting slots did not zero out the deleted slots properly.\n\nConsider a dynamically-sized array in storage whose base-type is small enough...","url":"/blog/2020/10/07/solidity-dynamic-array-cleanup-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity Memory Array Creation Overflow Bug","date":"2020-04-06","author":"Solidity Team","category":"Security Alerts"},"content":"\nOn the 28th of March, a bug in the Solidity code generator was reported through the\nEthereum Foundation Bounty program,\nby John Toman of Certora. The bug is fixed with version 0.6.5,\nreleased on 2020-04-06.\nThe bug is present in all prior versions of Solidity.\n\nWe assigned a severity level of \"low\" because we found the bug to be uncommon and at the same time hard to exploit.\n\nWho should be concerned\n\nIf you have deployed a contract which allocates a memory array of user-supplied length,\nbut does...","url":"/blog/2020/04/06/memory-creation-overflow-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity Storage Array Bugs","date":"2019-06-25","author":"Solidity and Security Team","category":"Security Alerts"},"content":"\nThis post was originally published on the Ethereum blog.\n\nThis blog post is about two bugs connected to storage arrays which are otherwise unrelated. Both have been present in the compiler for a long time and have only been discovered now even though a contract containing them should very likely show malfunctions in tests.\n\nDaenam Kim with help from Nguyen Pham, both from Curvegrid discovered an issue where invalid data is stored in connection with arrays of signed integers.\n\nThis bug has been...","url":"/blog/2019/06/25/solidity-storage-array-bugs"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity Optimizer and ABIEncoderV2 Bugs","date":"2019-03-26","author":"Solidity and Security Team","category":"Security Alerts"},"content":"\nThis post was originally published on the Ethereum blog.\n\nThrough the Ethereum bug bounty program, we received a report about a flaw within the new experimental ABI encoder (referred to as ABIEncoderV2). Upon investigation, it was found that the component suffers from a few different variations of the same type. The first part of this announcement explains this bug in detail. The new ABI encoder is still marked as experimental, but we nevertheless think that this deserves a prominent announcement since...","url":"/blog/2019/03/26/solidity-optimizer-and-abiencoderv2-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity Bugfix Release","date":"2018-09-13","author":"Solidity Team","category":"Security Alerts"},"content":"\nThis post was originally published on the Ethereum blog.\n\nThe latest version 0.4.25 release of Solidity fixes\ntwo important bugs.\nAnother important bug has already been fixed in version 0.4.22 but it was only discovered recently that the bug existed.\n\nNote that the Ethereum Foundation runs a bounty program for the code generator part of Solidity.\n\nCleanup of Exponent in Exponentiation\n\nLikelihood of occurrence: very low\nExploitability: high\nDiscoverability by tests: low\nFixed in version: 0.4.25\n\nSummary: Using short types in the exponent of an exponentiation operation can lead to...","url":"/blog/2018/09/13/solidity-bugfix-release"},{"frontmatter":{"layout":"post","published":true,"title":"Solidity Optimizer Bug","date":"2017-05-03","author":"Martin Swende","category":"Security Alerts"},"content":"\nThis post was originally published on the Ethereum blog.\n\nA bug in the Solidity optimizer was reported through the Ethereum Foundation Bounty program, by Christoph Jentzsch. This bug is patched as of 2017-05-03, with the release of Solidity 0.4.11.\n\nBackground\n\nThe bug in question concerned how the optimizer optimizes on constants in the byte code. By \"byte code constants\", we mean anything which is PUSHed on the stack (not to be confused with Solidity constants). For example, if the value 0xfffffffffffffffffffffffffffffffffffffffffffffffe is PUSHed,...","url":"/blog/2017/05/03/solidity-optimizer-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Analysis of Storage Corruption Bug","date":"2016-11-09","author":"Christian Reitwiessner","category":"Security Alerts"},"content":"\nThis post was originally published on the Ethereum blog.\n\nThis blog post provides an update on our findings following the discovery of the storage corruption bug last week.\nIn summary, the bug was much less severe than we initially thought. The small number of affected contracts we found is either only exploitable by the owner, or the exploit can only cause a disruption in the user interface and not in the actual contract logic. All exploitable contracts/dapps we reviewed can be fixed...","url":"/blog/2016/11/09/analysis-storage-corruption-bug"},{"frontmatter":{"layout":"post","published":true,"title":"Security Alert: Variables can be overwritten in storage","date":"2016-11-01","author":"Christian Reitwiessner","category":"Security Alerts"},"content":"\nThis post was originally published on the Ethereum blog.\n\nSummary: In some situations, variables can overwrite other variables in storage.\n\n*Affected Solidity compiler versions: *0.1.6 to 0.4.3 (including 0.4.4 pre-release versions)\n\nDetailed description:\n\nStorage variables that are smaller than 256 bits are packed together into the same 256 bit slot if they can fit. If a value larger than what is allowed by the type is assigned to the first variable, that value will overwrite the second variable.\n\nThis means if an attacker can cause...","url":"/blog/2016/11/01/security-alert-solidity-variables-can-overwritten-storage"},{"frontmatter":{"layout":"post","published":true,"title":"Smart Contract Security","date":"2016-06-10","author":"Christian Reitwiessner","category":"Security Alerts"},"content":"\nThis post was originally published on the Ethereum blog.\n\nSolidity was started in October 2014 when neither the Ethereum network nor the virtual machine had any real-world testing, the gas costs at that time were even drastically different from what they are now. Furthermore, some of the early design decisions were taken over from Serpent. During the last couple of months, examples and patterns that were initially considered best-practice were exposed to reality and some of them actually turned out to...","url":"/blog/2016/06/10/smart-contract-security"}],"category":"Security Alerts"},"__N_SSG":true}